// HighstockTradingViewChart.js
import React, { useState, useEffect, useRef } from 'react';
import dynamic from 'next/dynamic';
import PropTypes from 'prop-types';

// Dynamic imports for Highcharts modules on client side only
const initHighcharts = async () => {
  // Only import on client side
  if (typeof window === 'undefined') return null;
  
  try {
    // Import Highcharts
    const Highcharts = await import('highcharts/highstock');

    // We need to ensure we get the default export
    const highchartsInstance = Highcharts.default || Highcharts;

    // First load core modules that others depend on
    console.log("Loading core modules...");
    try {
      // Load indicators module first as others may depend on it
      const indicators = await import('highcharts/indicators/indicators');
      const indicatorsModule = indicators.default || indicators;
      if (typeof indicatorsModule === 'function') {
        indicatorsModule(highchartsInstance);
        console.log("Indicators module loaded successfully");
      } else {
        console.warn("Indicators module is not a function:", typeof indicatorsModule);
      }
    } catch (err) {
      console.error("Error loading indicators module:", err);
    }

    // Load the rest of the modules one by one with proper error handling
    const moduleLoaders = [
      { name: "annotations-advanced", loader: () => import('highcharts/modules/annotations-advanced') },
      { name: "drag-panes", loader: () => import('highcharts/modules/drag-panes') },
      { name: "full-screen", loader: () => import('highcharts/modules/full-screen') },
      { name: "price-indicator", loader: () => import('highcharts/modules/price-indicator') },
      // Load stock-tools last since it depends on other modules
      { name: "stock-tools", loader: () => import('highcharts/modules/stock-tools') }
    ];

    // Load each module separately with error handling
    for (const { name, loader } of moduleLoaders) {
      try {
        const module = await loader();
        const mod = module.default || module;
        
        if (typeof mod === 'function') {
          mod(highchartsInstance);
          console.log(`${name} module loaded successfully`);
        } else if (typeof mod === 'object' && mod.__esModule) {
          // Handle ES modules
          let loaded = false;
          Object.values(mod).forEach(submod => {
            if (typeof submod === 'function') {
              submod(highchartsInstance);
              loaded = true;
            }
          });
          if (loaded) {
            console.log(`${name} module loaded successfully (ES Module)`);
          } else {
            console.warn(`${name} module has no usable exports:`, mod);
          }
        } else {
          console.warn(`Could not initialize ${name} module:`, mod);
        }
      } catch (err) {
        console.error(`Error loading ${name} module:`, err);
      }
    }
    
    // CSS is now handled in _document.js
    
    return highchartsInstance;
  } catch (error) {
    console.error('Error initializing Highcharts:', error);
    return null;
  }
};

/**
 * A TradingView-like chart component using Highstock with drawing tools and price-to-bar ratio locking
 * 
 * This component renders a financial chart with:
 * - Manual drawing tools (via Stock Tools module)
 * - Ability to lock price-to-bar ratio (aspect ratio) to maintain angle consistency
 * - OHLC/Candlestick data visualization
 */
const HighstockTradingViewChart = ({ 
  data = [], 
  title = 'Price Chart',
  initialPriceToBarRatio = 0.00369, // Default ratio as per requirements
}) => {
  const chartRef = useRef(null);
  const chartInstanceRef = useRef(null);
  const [priceToBarRatio, setPriceToBarRatio] = useState(initialPriceToBarRatio);
  const [priceToBarRatioText, setPriceToBarRatioText] = useState(initialPriceToBarRatio.toString());
  const [isRatioLocked, setIsRatioLocked] = useState(true);
  const [chartOptions, setChartOptions] = useState(null);
  const [drawnLineInfo, setDrawnLineInfo] = useState(null);
  const [highcharts, setHighcharts] = useState(null);

  // Initialize Highcharts on client-side only
  useEffect(() => {
    const loadHighcharts = async () => {
      console.log("Starting Highcharts initialization");
      try {
        const highchartsInstance = await initHighcharts();
        console.log("Highcharts initialized successfully:", {
          hasInstance: !!highchartsInstance,
          hasStockChart: !!highchartsInstance?.stockChart
        });
        setHighcharts(highchartsInstance);
      } catch (error) {
        console.error("Failed to initialize Highcharts:", error);
      }
    };
    
    loadHighcharts();
  }, []);

  // Function to calculate angle between two points
  const calculateAngle = (x1, y1, x2, y2) => {
    try {
      // Calculate angle in radians, then convert to degrees
      const angleRad = Math.atan2(y2 - y1, x2 - x1);
      const angleDeg = angleRad * (180 / Math.PI);
      
      // Adjust to get angle from horizontal
      let angle = 90 - angleDeg;
      
      // Normalize to 0-360 range
      if (angle < 0) angle += 360;
      if (angle >= 360) angle -= 360;
      
      // Round to one decimal place
      return parseFloat(angle.toFixed(1));
    } catch (error) {
      console.error('Error calculating angle:', error);
      return 0;
    }
  };

  // Generate chart options when data or ratio changes
  useEffect(() => {
    if (!highcharts || !data || data.length === 0) {
      console.log("Cannot generate chart options:", {
        hasHighcharts: !!highcharts,
        hasData: !!data,
        dataLength: data?.length
      });
      return;
    }

    console.log("Generating chart options with data:", {
      dataLength: data.length,
      firstPoint: data[0],
      lastPoint: data[data.length - 1],
      isArray: Array.isArray(data[0])
    });

    // Process the data to OHLC format if needed
    const ohlcData = Array.isArray(data[0]) ? data : data.map(point => [
      point.timestamp || point.date || point.x,
      point.open,
      point.high,
      point.low,
      point.close
    ]);

    console.log("Processed OHLC data:", {
      length: ohlcData.length,
      firstPoint: ohlcData[0],
      lastPoint: ohlcData[ohlcData.length - 1],
      isValid: ohlcData.every(point => 
        point.length >= 5 && 
        !isNaN(point[1]) && 
        !isNaN(point[2]) && 
        !isNaN(point[3]) && 
        !isNaN(point[4])
      )
    });

    // Create volume data array if available
    const volumeData = Array.isArray(data[0]) && data[0].length >= 6 ? 
      data.map(point => [
        point[0], // timestamp
        point[5]  // volume
      ]) : [];

    console.log("Volume data:", {
      hasVolume: volumeData.length > 0,
      length: volumeData.length,
      firstPoint: volumeData[0]
    });

    // Calculate min, max values of price for Y-axis scaling
    const priceValues = ohlcData.flatMap(point => [point[1], point[2], point[3], point[4]]);
    const minPrice = Math.min(...priceValues);
    const maxPrice = Math.max(...priceValues);
    const priceRange = maxPrice - minPrice;

    console.log("Price range:", {
      min: minPrice,
      max: maxPrice,
      range: priceRange
    });

    // Date range for X-axis
    const startDate = ohlcData[0][0];
    const endDate = ohlcData[ohlcData.length - 1][0];
    const timeRange = endDate - startDate;

    console.log("Time range:", {
      start: new Date(startDate).toISOString(),
      end: new Date(endDate).toISOString(),
      range: timeRange
    });

    // Calculate the appropriate Y-axis max/min based on the price-to-bar ratio
    const barCount = ohlcData.length;
    
    // FIXED: Use proper ratio calculation without the timeRange factor
    const adjustedPriceRange = priceToBarRatio * barCount;
    
    // Add padding to ensure values are visible
    const paddingFactor = 0.1; // 10% padding
    const paddingAmount = priceRange * paddingFactor;
    
    const centerPrice = (maxPrice + minPrice) / 2;
    const yAxisMin = Math.max(minPrice - paddingAmount, centerPrice - adjustedPriceRange / 2);
    const yAxisMax = Math.min(maxPrice + paddingAmount, centerPrice + adjustedPriceRange / 2);

    console.log("Y-axis configuration:", {
      barCount,
      adjustedPriceRange,
      centerPrice,
      yAxisMin,
      yAxisMax
    });

    const options = {
      chart: {
        height: 600,
        animation: false,
        panning: {
          enabled: true,
          type: 'xy'  // Allow panning in both x and y directions
        },
        panKey: 'shift', // Require shift key for y-axis panning
        zoomType: null,  // Disable rectangle zoom by setting zoomType to null
        events: {
          // Handle events related to drawing
          afterSetExtremes: function(e) {
            console.log("Chart afterSetExtremes called:", { 
              isRatioLocked,
              source: e?.target?.coll || 'unknown'
            });
            
            // Skip if ratio not locked or if this is from Y-axis (to avoid loops)
            if (!isRatioLocked || (e && e.target && e.target.coll === 'yAxis')) return;
            
            // The remaining logic moves to the xAxis.events.afterSetExtremes handler
          },
          // Add a load event to initialize the fixed price display box
          load: function() {
            try {
              // We're no longer creating the fixed price box here since we now have the ohlc-display element
              console.log('Chart loaded successfully');
            } catch (error) {
              console.error('Error in chart load event:', error);
            }
          },
          // Add a separate pointer move event to update the fixed box
          render: function() {
            // No need to handle the fixed price box positioning anymore
            // Just add any render-specific logic here if needed
          }
        }
      },
      rangeSelector: {
        enabled: true,
        selected: 1
      },
      navigator: {
        enabled: true
      },
      scrollbar: {
        enabled: true
      },
      title: {
        text: title
      },
      // Stock tools configuration for drawing
      stockTools: {
        gui: {
          enabled: true,
          positioned: 'left',
          iconsURL: 'https://code.highcharts.com/stock/10/gfx/stock-icons/', // Make sure icons are loaded
          buttons: [
            'indicators',
            'separator',
            'simpleShapes',
            'lines',
            {
              id: 'angle-tool',
              title: 'Angle Tool',
              className: 'highcharts-angle-tool',
              symbol: 'line.svg'  // Using line icon for angle tool
            },
            'crookedLines',
            'measure',
            'advanced',
            'toggleAnnotations',
            'separator',
            'verticalLabels',
            'flags',
            'separator',
            'zoomChange',
            'fullScreen',
            'typeChange',
            'separator',
            'currentPriceIndicator',
            'saveChart'
          ]
        }
      },
      navigation: {
        bindingsClassName: 'tools-container',
        menuItemStyle: {
          padding: '0.5em'
        },
        menuItemHoverStyle: {
          background: '#4572A7',
          color: '#FFFFFF'
        },
        bindings: {
          // Add a custom binding for the angle tool
          angleToolBinding: {
            className: 'highcharts-angle-tool',
            init: function(e) {
              // When the angle tool button is clicked, this function will run
              const chart = this.chart;
              console.log('Angle tool initialized');
              
              // Set state to drawing mode
              this.isDrawing = true;
              
              // Set first point 
              this.firstPoint = null;
              
              // Display a message to the user
              if (chart.ohlcDisplay) {
                document.getElementById('ohlc-display').innerHTML = 
                  '<span style="color:#428bca;font-weight:bold">Angle Tool: Click to set first point</span>';
              }
              
              // Add a click event listener to the chart container
              this.clickHandler = (clickEvent) => {
                console.log('Click detected in angle tool', clickEvent);
                if (!this.isDrawing) return;
                
                const normalizedEvent = this.chart.pointer.normalize(clickEvent);
                
                if (!this.firstPoint) {
                  // First click - store the point
                  this.firstPoint = {
                    x: normalizedEvent.chartX,
                    y: normalizedEvent.chartY
                  };
                  console.log('First point set:', this.firstPoint);
                  
                  // Update instruction message
                  if (chart.ohlcDisplay) {
                    document.getElementById('ohlc-display').innerHTML = 
                      '<span style="color:#428bca;font-weight:bold">Angle Tool: Click to set second point</span>';
                  }
                } else {
                  // Second click - draw the angle
                  const secondPoint = {
                    x: normalizedEvent.chartX,
                    y: normalizedEvent.chartY
                  };
                  console.log('Second point set:', secondPoint);
                  
                  // Convert pixel coordinates to axis values
                  const x1 = this.chart.xAxis[0].toValue(this.firstPoint.x);
                  const y1 = this.chart.yAxis[0].toValue(this.firstPoint.y);
                  const x2 = this.chart.xAxis[0].toValue(secondPoint.x);
                  const y2 = this.chart.yAxis[0].toValue(secondPoint.y);
                  
                  console.log('Converted points:', { x1, y1, x2, y2 });
                  
                  // Add line annotation
                  const annotation = this.chart.addAnnotation({
                    shapes: [{
                      type: 'path',
                      points: [
                        { x: x1, y: y1 },
                        { x: x2, y: y2 }
                      ]
                    }],
                    draggable: true
                  });
                  
                  console.log('Line annotation added:', annotation);
                  
                  // Calculate and display the angle
                  if (typeof window !== 'undefined') {
                    try {
                      // Calculate angle
                      const angleRadians = Math.atan2(y2 - y1, x2 - x1);
                      const angleDegrees = angleRadians * (180 / Math.PI);
                      
                      // Normalize the angle to 0-360
                      let angle = 90 - angleDegrees;
                      if (angle < 0) angle += 360;
                      if (angle >= 360) angle -= 360;
                      
                      // Round to one decimal place
                      const roundedAngle = parseFloat(angle.toFixed(1));
                      
                      console.log('Angle calculated:', roundedAngle);
                      
                      // Create a more prominent angle label
                      this.chart.addAnnotation({
                        labels: [{
                          point: { x: (x1 + x2) / 2, y: (y1 + y2) / 2 },
                          text: `${roundedAngle}°`,
                          shape: 'circle',
                          backgroundColor: 'rgba(66, 139, 202, 0.85)',
                          borderWidth: 2,
                          borderColor: '#fff',
                          borderRadius: 25,
                          padding: 10,
                          style: {
                            fontSize: '14px',
                            fontWeight: 'bold',
                            color: '#fff',
                            textAlign: 'center'
                          },
                          y: -35,
                          useHTML: true
                        }],
                        draggable: false,
                        shapeOptions: {
                          fill: 'transparent',
                          stroke: 'transparent'
                        }
                      });
                      
                      // Also add a visual angle indicator
                      const radius = 40;
                      const startPoint = { x: x1, y: y1 };
                      
                      const angleInRadians = (90 - angle) * Math.PI / 180;
                      const endX = x1 + radius * Math.cos(angleInRadians);
                      const endY = y1 + radius * Math.sin(angleInRadians);
                      
                      this.chart.addAnnotation({
                        shapes: [{
                          type: 'path',
                          points: [
                            { x: x1, y: y1 },
                            { x: x1 + radius, y: y1 }, // Horizontal line
                            { x: x1, y: y1 }, // Back to start for the second line
                            { x: endX, y: endY } // Line at the calculated angle
                          ],
                          strokeWidth: 2,
                          stroke: 'rgba(66, 139, 202, 0.85)'
                        }],
                        draggable: false
                      });
                      
                      console.log('Angle indicator added');
                    } catch (error) {
                      console.error('Error calculating angle:', error);
                    }
                  }
                  
                  // Reset the tool
                  this.isDrawing = false;
                  this.firstPoint = null;
                  
                  // Remove the event listener
                  this.chart.container.removeEventListener('click', this.clickHandler);
                  
                  // Reset the instruction message
                  if (chart.ohlcDisplay) {
                    document.getElementById('ohlc-display').innerHTML = 
                      '<span>Hover over candle</span>';
                  }
                }
              };
              
              this.chart.container.addEventListener('click', this.clickHandler);
            },
            
            // When the binding is cancelled (e.g., user selects another tool)
            close: function() {
              console.log('Closing angle tool');
              if (this.clickHandler) {
                this.chart.container.removeEventListener('click', this.clickHandler);
              }
              
              this.isDrawing = false;
              this.firstPoint = null;
              
              // Reset the instruction message
              if (this.chart.ohlcDisplay) {
                document.getElementById('ohlc-display').innerHTML = 
                  '<span>Hover over candle</span>';
              }
            }
          },
          
          // Override the standard line tool to include angle display
          line: {
            // Keep the original line tool functionality but add angle display
            end: function(e) {
              console.log('Line tool end event triggered');
              
              // Get the annotation that was just created
              if (this.chart && this.chart.annotations && this.chart.annotations.length > 0) {
                const annotation = this.chart.annotations[this.chart.annotations.length - 1];
                
                // Process only if it's a line annotation
                if (annotation && annotation.options && annotation.options.shapes && 
                    annotation.options.shapes[0].type === 'path') {
                  
                  const shape = annotation.shapes[0];
                  const points = shape.points || [];
                  
                  if (points.length === 2) {
                    const p1 = points[0];
                    const p2 = points[1];
                    
                    // Get actual coordinates in both axis scales
                    const x1 = p1.x;
                    const y1 = p1.y;
                    const x2 = p2.x;
                    const y2 = p2.y;
                    
                    if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                      console.warn('Invalid coordinates for angle calculation:', { x1, y1, x2, y2 });
                      return;
                    }
                    
                    try {
                      // Calculate angle in radians, then convert to degrees
                      const angleRad = Math.atan2(y2 - y1, x2 - x1);
                      const angleDeg = angleRad * (180 / Math.PI);
                      
                      // Adjust to get angle from horizontal
                      let angle = 90 - angleDeg;
                      
                      // Normalize to 0-360 range
                      if (angle < 0) angle += 360;
                      if (angle >= 360) angle -= 360;
                      
                      // Round to one decimal place
                      const roundedAngle = parseFloat(angle.toFixed(1));
                      
                      console.log('Standard line tool: Angle calculated:', roundedAngle);
                      
                      // Store the drawn line info in component state
                      if (typeof setDrawnLineInfo === 'function') {
                        setDrawnLineInfo({
                          start: { x: x1, y: y1 },
                          end: { x: x2, y: y2 },
                          angle: roundedAngle
                        });
                      }
                      
                      // Create a more prominent angle label
                      this.chart.addAnnotation({
                        labels: [{
                          point: { x: (x1 + x2) / 2, y: (y1 + y2) / 2 },
                          text: `${roundedAngle}°`,
                          shape: 'circle',
                          backgroundColor: 'rgba(66, 139, 202, 0.85)',
                          borderWidth: 2,
                          borderColor: '#fff',
                          borderRadius: 25,
                          padding: 10,
                          style: {
                            fontSize: '14px',
                            fontWeight: 'bold',
                            color: '#fff',
                            textAlign: 'center'
                          },
                          y: -35,
                          useHTML: true
                        }],
                        draggable: false,
                        shapeOptions: {
                          fill: 'transparent',
                          stroke: 'transparent'
                        }
                      });
                      
                      // Also add a visual angle indicator
                      const radius = 40;
                      
                      const angleInRadians = (90 - angle) * Math.PI / 180;
                      const endX = x1 + radius * Math.cos(angleInRadians);
                      const endY = y1 + radius * Math.sin(angleInRadians);
                      
                      this.chart.addAnnotation({
                        shapes: [{
                          type: 'path',
                          points: [
                            { x: x1, y: y1 },
                            { x: x1 + radius, y: y1 }, // Horizontal line
                            { x: x1, y: y1 }, // Back to start for the second line
                            { x: endX, y: endY } // Line at the calculated angle
                          ],
                          strokeWidth: 2,
                          stroke: 'rgba(66, 139, 202, 0.85)'
                        }],
                        draggable: false
                      });
                      
                      console.log('Standard line tool: Angle indicator added');
                    } catch (error) {
                      console.error('Error calculating angle in standard line tool:', error);
                    }
                  }
                }
              }
            }
          },
          
          // Remove the custom drawLineBinding as we're now enhancing the standard line tool directly
          drawLineBinding: undefined
        },
        events: {
          // This event fires when a new annotation is added
          selectButton: function(event) {
            const button = event.button;
            // Handle specific drawing tools
            if (button && button.classList && button.classList.contains('highcharts-draw-line')) {
              console.log('Line drawing tool selected');
            }
          },
          // Capture when an annotation is added
          afterAddAnnotation: function(event) {
            if (!event || !event.annotation) return;
            
            try {
              const annotation = event.annotation;
              console.log('Annotation added:', annotation);
              
              // For line annotations, calculate and display the angle
              if (annotation.options && annotation.options.shapes && 
                  annotation.options.shapes[0].type === 'path') {
                
                const shape = annotation.shapes[0];
                const points = shape.points || [];
                
                if (points.length === 2) {
                  const p1 = points[0];
                  const p2 = points[1];
                  
                  // Get actual coordinates in both axis scales
                  const x1 = p1.x;
                  const y1 = p1.y;
                  const x2 = p2.x;
                  const y2 = p2.y;
                  
                  if (isNaN(x1) || isNaN(y1) || isNaN(x2) || isNaN(y2)) {
                    console.warn('Invalid coordinates for angle calculation:', { x1, y1, x2, y2 });
                    return;
                  }
                  
                  const angle = calculateAngle(x1, y1, x2, y2);
                  console.log('Event handler: Angle calculated:', angle);
                  
                  setDrawnLineInfo({
                    start: { x: x1, y: y1 },
                    end: { x: x2, y: y2 },
                    angle: angle
                  });
                  
                  // Note: We no longer need to create the angle indicators here
                  // because they are now handled directly in the tool bindings
                }
              }
            } catch (error) {
              console.error('Error processing annotation:', error);
            }
          }
        }
      },
      xAxis: {
        ordinal: false,     // Disable ordinal axis to allow panning to empty areas
        minRange: 24 * 3600 * 1000, // Minimum range of 1 day to prevent excessive zoom
        overscroll: 0.5,    // Allow overscroll beyond data points (50% of the visible range)
        min: null,          // Remove min constraint
        max: null,          // Remove max constraint
        events: {
          afterSetExtremes: function(e) {
            if (!isRatioLocked) return;
            
            console.log("X-axis extremes changed:", {
              min: e.min,
              max: e.max,
              trigger: e.trigger
            });
            
            try {
              const xAxis = this;
              const yAxis = this.chart.yAxis[0];
              
              // Current ranges after zoom/pan
              const currentXRange = xAxis.max - xAxis.min;
              
              // Calculate how many bars are visible in the current view
              // We need to handle edge cases where data might not be evenly distributed
              const timePerBar = (endDate - startDate) / barCount;
              const barsInView = Math.round(currentXRange / timePerBar);
              
              // Calculate the appropriate Y-axis range based on the price-to-bar ratio
              const newYRange = priceToBarRatio * barsInView;
              
              // Get current center point of view
              const centerY = (yAxis.max + yAxis.min) / 2;
              
              console.log("Adjusting Y-axis to maintain ratio:", {
                barCount,
                timePerBar,
                barsInView,
                currentXRange,
                priceToBarRatio,
                newYRange,
                centerY,
                newMin: centerY - newYRange / 2,
                newMax: centerY + newYRange / 2
              });
              
              // Only set extremes if values are valid and significantly different
              if (!isNaN(newYRange) && newYRange > 0 && 
                  isFinite(centerY - newYRange / 2) && isFinite(centerY + newYRange / 2)) {
                yAxis.setExtremes(
                  centerY - newYRange / 2,
                  centerY + newYRange / 2,
                  true, // Animation
                  false // Don't redraw yet (prevent loop)
                );
                
                // Force redraw to ensure changes take effect
                setTimeout(() => {
                  try {
                    if (this.chart) {
                      this.chart.redraw(false);
                  }
                  } catch (error) {
                    console.error('Error redrawing chart:', error);
                  }
                }, 10);
              } else {
                console.warn('Invalid Y-axis range calculated:', {
                  newYRange,
                  centerY,
                  min: centerY - newYRange / 2,
                  max: centerY + newYRange / 2
                });
              }
            } catch (error) {
              console.error('Error in afterSetExtremes:', error);
            }
          }
        }
      },
      yAxis: [{
        // Configure Y-axis with min/max to enforce the price-to-bar ratio
        min: yAxisMin,
        max: yAxisMax,
        startOnTick: false,
        endOnTick: false,
        minPadding: 0.2,    // Add padding to allow panning beyond data points
        maxPadding: 0.2,    // Add padding to allow panning beyond data points
        overscroll: 0.2,    // Allow overscroll beyond min/max (20%)
        labels: {
          align: 'right',
          x: -3
        },
        title: {
          text: 'Price'
        },
        height: '60%',
        lineWidth: 2,
        resize: {
          enabled: true
        }
      }, {
        // Add volume axis below the price chart
        labels: {
          align: 'right',
          x: -3
        },
        title: {
          text: 'Volume'
        },
        top: '65%',
        height: '35%',
        offset: 0,
        lineWidth: 2
      }],
      tooltip: {
        split: false,
        shared: true,
        useHTML: true,
        positioner: function() {
          // Position the tooltip away from the fixed OHLC display
          return { x: 80, y: 50 };
        },
        formatter: function() {
          try {
            // Get the point data
            if (!this.points || !this.points.length) {
              return '';
            }
            
            const point = this.points[0];
            if (!point || !point.point) {
              return '';
            }
            
            const ohlc = point.point;
            
            // Format date manually to avoid Highcharts global reference
            const formatDate = (date) => {
              if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return 'Invalid Date';
              }
              const pad = (num) => (num < 10 ? '0' + num : num);
              const year = date.getFullYear();
              const month = pad(date.getMonth() + 1);
              const day = pad(date.getDate());
              return `${year}-${month}-${day}`;
            };
            
            const formatTime = (date) => {
              if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return '';
              }
              const pad = (num) => (num < 10 ? '0' + num : num);
              const hours = pad(date.getHours());
              const minutes = pad(date.getMinutes());
              return `${hours}:${minutes}`;
            };
            
            // Format numbers with 2 decimal places
            const formatNumber = (num, decimals = 2) => {
              // More thorough check for valid number
              if (num === undefined || num === null || typeof num !== 'number' || isNaN(num)) {
                return '-';
              }
              return num.toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
            };
            
            // Ensure we have a valid timestamp
            if (!ohlc || !ohlc.x) {
              return '';
            }
            
            const date = new Date(ohlc.x);
            const formattedDate = formatDate(date);
            const time = formatTime(date);
            
            // Create HTML content for the OHLC display with safer checks
            let ohlcHtml = `<span style="font-weight:bold">${formattedDate} ${time}</span> &nbsp; | &nbsp;`;
            
            // Make sure we have valid properties before trying to format them
            if (ohlc.open !== undefined && ohlc.open !== null && typeof ohlc.open === 'number') {
              ohlcHtml += `<span style="color:#333">O:</span> <span style="font-weight:bold">${formatNumber(ohlc.open)}</span> &nbsp;`;
            } else {
              ohlcHtml += `<span style="color:#333">O:</span> <span style="font-weight:bold">-</span> &nbsp;`;
            }
            
            if (ohlc.high !== undefined && ohlc.high !== null && typeof ohlc.high === 'number') {
              ohlcHtml += `<span style="color:#333">H:</span> <span style="font-weight:bold">${formatNumber(ohlc.high)}</span> &nbsp;`;
            } else {
              ohlcHtml += `<span style="color:#333">H:</span> <span style="font-weight:bold">-</span> &nbsp;`;
            }
            
            if (ohlc.low !== undefined && ohlc.low !== null && typeof ohlc.low === 'number') {
              ohlcHtml += `<span style="color:#333">L:</span> <span style="font-weight:bold">${formatNumber(ohlc.low)}</span> &nbsp;`;
            } else {
              ohlcHtml += `<span style="color:#333">L:</span> <span style="font-weight:bold">-</span> &nbsp;`;
            }
            
            if (ohlc.close !== undefined && ohlc.close !== null && typeof ohlc.close === 'number') {
              ohlcHtml += `<span style="color:#333">C:</span> <span style="font-weight:bold">${formatNumber(ohlc.close)}</span> &nbsp;`;
            } else {
              ohlcHtml += `<span style="color:#333">C:</span> <span style="font-weight:bold">-</span> &nbsp;`;
            }
            
            // If volume data is available
            if (this.points.length > 1) {
              const volumePoint = this.points[1];
              if (volumePoint && volumePoint.y !== undefined && volumePoint.y !== null && typeof volumePoint.y === 'number') {
                ohlcHtml += `<span style="color:#3060cf">V:</span> <span style="font-weight:bold">${formatNumber(volumePoint.y, 0)}</span>`;
              } else {
                ohlcHtml += `<span style="color:#3060cf">V:</span> <span style="font-weight:bold">-</span>`;
              }
            }
            
            // Update the OHLC display in the controls area
            const ohlcDisplay = document.getElementById('ohlc-display');
            if (ohlcDisplay) {
              ohlcDisplay.innerHTML = ohlcHtml;
            }
            
            // Return empty string for tooltip (we're using the separate OHLC display)
            return '';
          } catch (error) {
            console.error('Error in tooltip formatter:', error);
            
            // Update display with error info
            try {
              const ohlcDisplay = document.getElementById('ohlc-display');
              if (ohlcDisplay) {
                ohlcDisplay.innerHTML = '<span>Hover over candle</span>';
              }
            } catch (e) {
              // Fail silently
            }
            
            return '';
          }
        }
      },
      series: [
        {
          type: 'candlestick',
          name: 'Price',
          id: 'price_chart',
          data: ohlcData,
          tooltip: {
            valueDecimals: 2
          },
          // Add more styling for candlesticks to make them more visible
          color: '#ef5350',
          upColor: '#26a69a',
          lineColor: '#ef5350',
          upLineColor: '#26a69a',
          states: {
            hover: {
              brightness: 0.1
            }
          },
          dataGrouping: {
            enabled: false // Disable data grouping to ensure candlesticks are shown as-is
          }
        },
        // Add volume series if available
        ...(volumeData.length > 0 ? [{
          type: 'column',
          name: 'Volume',
          id: 'volume_chart',
          data: volumeData,
          yAxis: 1,
          color: 'rgba(100, 100, 255, 0.5)'
        }] : [])
      ]
    };

    console.log("Generated chart options:", {
      hasData: !!options.series?.[0]?.data,
      dataLength: options.series?.[0]?.data?.length,
      hasVolume: !!options.series?.[1],
      yAxisConfig: options.yAxis?.[0],
      hasAngleBinding: !!options.navigation?.bindings?.angleToolBinding
    });

    setChartOptions(options);
  }, [data, priceToBarRatio, isRatioLocked, title, highcharts]);

  // Create or update chart when options change
  useEffect(() => {
    if (!highcharts || !chartOptions) {
      console.log("Cannot create/update chart:", {
        hasHighcharts: !!highcharts,
        hasOptions: !!chartOptions
      });
      return;
    }
    
    console.log("Creating/updating chart:", {
      hasData: !!chartOptions.series?.[0]?.data,
      dataLength: chartOptions.series?.[0]?.data?.length,
      hasVolume: !!chartOptions.series?.[1],
      hasContainer: !!chartRef.current
    });
    
    // Create new chart if it doesn't exist
    if (!chartInstanceRef.current && chartRef.current) {
      console.log("Creating new chart instance");
      try {
        // Set up global options for better toolbar visibility
        highcharts.setOptions({
          lang: {
            stockTools: {
              gui: {
                drawingTools: {
                  label: 'Drawing Tools',
                  buttons: {
                    angleTool: 'Angle Tool',
                    line: 'Line (with angle)',
                    rectangle: 'Rectangle',
                    circle: 'Circle',
                    label: 'Label',
                    segment: 'Segment',
                    arrowSegment: 'Arrow segment',
                    ray: 'Ray',
                    arrowRay: 'Arrow ray',
                    infinity: 'Infinity line',
                    arrow: 'Arrow',
                    horizontalLine: 'Horizontal line',
                    verticalLine: 'Vertical line',
                    crooked3: 'Crooked line 3 points',
                    crooked5: 'Crooked line 5 points',
                    elliott3: 'Elliott 3 line',
                    elliott5: 'Elliott 5 line',
                    measureXY: 'Measure XY',
                    measureX: 'Measure X',
                    measureY: 'Measure Y'
                  }
                },
                zoomTools: {
                  label: 'Zoom Tools',
                  buttons: {
                    typeChange: 'Type change',
                    typeOHLC: 'OHLC',
                    typeLine: 'Line',
                    typeCandlestick: 'Candlestick'
                  }
                }
              }
            }
          }
        });
        
        // Create a safer version of chartOptions with a more conservative stock tools config
        const safeChartOptions = {
          ...chartOptions,
          chart: {
            ...chartOptions.chart,
            // Explicitly enable free panning in any direction
            panning: {
              enabled: true,
              type: 'xy'
            },
            panKey: 'shift',
            zoomType: null, // Disable rectangle zoom by setting zoomType to null
          },
          xAxis: {
            ...chartOptions.xAxis,
            // Add more generous overscroll/padding
            ordinal: false,  // Ensure dates are linear and allow panning to empty areas
            overscroll: 1,   // Allow 100% overscroll beyond data points
            min: null,       // Remove min constraint completely
            max: null,       // Remove max constraint completely
            minPadding: 0.1, // Add 10% padding to both sides
            maxPadding: 0.1,
            minRange: 24 * 3600 * 1000 // Minimum range of 1 day 
          },
          yAxis: [
            {
              ...chartOptions.yAxis[0],
              // Add more generous overscroll/padding
              min: null,        // Remove min constraint
              max: null,        // Remove max constraint
              minPadding: 0.3,  // Add 30% padding to both sides
              maxPadding: 0.3,
              startOnTick: false,
              endOnTick: false,
              overscroll: 0.3   // Allow 30% overscroll
            },
            // Keep second yAxis (volume) as is
            chartOptions.yAxis[1]
          ],
          stockTools: {
            gui: {
              enabled: true,
              positioned: 'left',
              // Make sure buttons is an array of strings instead of a single string
              buttons: [
                'indicators',
                'separator',
                'simpleShapes',
                'lines',
                'separator',
                'verticalLabels',
                'flags',
                'separator',
                'zoomChange',
                'fullScreen',
                'typeChange',
                'separator',
                'currentPriceIndicator',
                'saveChart'
              ]
            }
          },
          navigation: {
            bindings: {
              ...chartOptions.navigation.bindings
            },
            events: chartOptions.navigation.events
          }
        };
        
        // Create the chart with the safer configuration
        chartInstanceRef.current = highcharts.stockChart(chartRef.current, safeChartOptions);
        console.log("Chart instance created successfully");
        
        // Add this code to force toolbar visibility
        // Add a direct DOM manipulation to ensure toolbar visibility after chart creation
        setTimeout(() => {
          try {
            // Force the stock tools to be visible by directly manipulating the DOM
            const guiContainer = document.querySelector('.highcharts-stocktools-wrapper');
            if (guiContainer) {
              console.log("Forcing stock tools wrapper visibility");
              guiContainer.style.display = 'block';
              guiContainer.style.visibility = 'visible';
              guiContainer.style.opacity = '1';
              guiContainer.style.zIndex = '999';
              
              // Also ensure the toolbar itself is visible
              const toolbar = document.querySelector('.highcharts-stocktools-toolbar');
              if (toolbar) {
                toolbar.style.display = 'block';
                toolbar.style.visibility = 'visible';
                toolbar.style.opacity = '1';
                
                // Make sure all buttons are visible
                const buttons = toolbar.querySelectorAll('.highcharts-menu-item');
                buttons.forEach(button => {
                  button.style.display = 'block';
                  const btnElement = button.querySelector('.highcharts-menu-item-btn');
                  if (btnElement) {
                    btnElement.style.display = 'block';
                  }
                });
              }
              
              // Force redraw
              if (chartInstanceRef.current) {
                chartInstanceRef.current.redraw();
              }
            } else {
              console.warn("Stock tools wrapper not found - trying to initialize stock tools");
              // If wrapper not found, try to initialize stock tools programmatically
              if (chartInstanceRef.current && highcharts.StockTools) {
                try {
                  new highcharts.StockTools(chartInstanceRef.current);
                  console.log("Stock tools initialized programmatically");
                } catch (err) {
                  console.error("Failed to initialize stock tools programmatically:", err);
                }
              }
            } catch (error) {
              console.error("Error forcing toolbar visibility:", error);
            }
          }, 1000); // Give it a bit more time to ensure DOM is ready
        
        // Now try to add the custom angle tool to the stock tools programmatically
        setTimeout(() => {
          try {
            if (chartInstanceRef.current && chartInstanceRef.current.stockTools) {
              console.log("Stock tools initialized:", chartInstanceRef.current.stockTools);
              
              // Try to ensure stock tools are visible
              const guiContainer = document.querySelector('.highcharts-stocktools-wrapper');
              if (guiContainer) {
                console.log("Stock tools GUI container found, ensuring visibility");
                guiContainer.style.display = 'block';
                guiContainer.style.visibility = 'visible';
                guiContainer.style.zIndex = '999';
                
                // Add custom angle tool button programmatically if needed
                try {
                  const toolbar = document.querySelector('.highcharts-stocktools-toolbar');
                  if (toolbar && !document.querySelector('.highcharts-angle-tool')) {
                    console.log("Adding angle tool button programmatically");
                    
                    // Create button container
                    const buttonContainer = document.createElement('li');
                    buttonContainer.className = 'highcharts-angle-tool';
                    buttonContainer.title = 'Angle Tool';
                    
                    // Create button
                    const button = document.createElement('span');
                    button.innerHTML = '∠'; // Use angle symbol
                    buttonContainer.appendChild(button);
                    
                    // Add click handler
                    buttonContainer.addEventListener('click', function() {
                      // Initialize angle tool
                      if (chartInstanceRef.current && chartInstanceRef.current.navigationBindings) {
                        chartInstanceRef.current.navigationBindings.selectedButtonElement = buttonContainer;
                        chartInstanceRef.current.navigationBindings.initEvents({
                          button: buttonContainer,
                          type: 'angleToolBinding'
                        });
                      }
                    });
                    
                    // Add to toolbar
                    toolbar.appendChild(buttonContainer);
                  }
                } catch (buttonError) {
                  console.error("Error adding angle tool button:", buttonError);
                }
              } else {
                console.warn("Stock tools GUI container not found");
              }
              
              // Force redraw
              chartInstanceRef.current.redraw();
            }
          } catch (error) {
            console.error("Error ensuring stock tools visibility:", error);
          }
        }, 500); // Small delay to ensure DOM is ready
        
        // Create the custom icon for angle tool if needed
        if (typeof document !== 'undefined') {
          // Add a style for the angle tool if it doesn't exist
          if (!document.getElementById('angle-tool-style')) {
            const style = document.createElement('style');
            style.id = 'angle-tool-style';
            style.innerHTML = `
              .highcharts-angle-tool > span {
                display: block;
                width: 28px;
                height: 28px;
                text-align: center;
                line-height: 28px;
                font-size: 20px;
                font-weight: bold;
                cursor: pointer;
              }
              .highcharts-menu-item-btn.highcharts-angle-tool-btn::before {
                content: '∠';
                font-size: 20px;
              }
            `;
            document.head.appendChild(style);
          }
        }
        
        // Fix the mousewheel handler to reference values correctly
        setTimeout(() => {
          try {
            if (chartInstanceRef.current && chartInstanceRef.current.container) {
              console.log("Adding mousewheel zoom handler");
              
              // Add mousewheel zoom handler
              const container = chartInstanceRef.current.container;
              container.addEventListener('wheel', function(e) {
                e.preventDefault(); // Prevent default scroll behavior
                
                const chart = chartInstanceRef.current;
                if (!chart) return;
                
                const xAxis = chart.xAxis[0];
                if (!xAxis) return;
                
                // Determine zoom direction
                const delta = e.deltaY || e.detail || e.wheelDelta;
                const zoomOut = delta > 0;
                
                // Get current extremes
                const min = xAxis.min;
                const max = xAxis.max;
                const range = max - min;
                
                // Calculate new range based on zoom factor
                const zoomFactor = zoomOut ? 1.1 : 0.9; // 10% zoom per wheel tick
                const newRange = range * zoomFactor;
                
                // Calculate center point (maintain position where mouse is)
                const offsetX = e.offsetX;
                const chartWidth = chart.chartWidth;
                const pointerX = xAxis.toValue(offsetX);
                
                // Calculate how far along the axis the pointer is (0 to 1)
                const pointerRatio = (pointerX - min) / range;
                
                // Calculate new min/max keeping the pointer position constant
                const newMin = pointerX - newRange * pointerRatio;
                const newMax = pointerX + newRange * (1 - pointerRatio);
                
                // Set new extremes
                xAxis.setExtremes(newMin, newMax, true, false);
                
                // If ratio is locked, also adjust the y-axis
                if (isRatioLocked) {
                  const yAxis = chart.yAxis[0];
                  if (yAxis) {
                    // Get actual data points from the series
                    const series = chart.series[0];
                    if (series && series.xData && series.xData.length > 0) {
                      const dataStartDate = series.xData[0];
                      const dataEndDate = series.xData[series.xData.length - 1];
                      const dataBarCount = series.xData.length;
                      
                      // Calculate time per bar based on actual data
                      const timePerBar = (dataEndDate - dataStartDate) / dataBarCount;
                      const barsInView = Math.round(newRange / timePerBar);
                      const newYRange = priceToBarRatio * barsInView;
                      const centerY = (yAxis.max + yAxis.min) / 2;
                      
                      yAxis.setExtremes(
                        centerY - newYRange / 2,
                        centerY + newYRange / 2,
                        true,
                        false
                      );
                    }
                  }
                }
                
                chart.redraw();
              }, { passive: false });
            }
          } catch (error) {
            console.error("Error setting up mousewheel zoom:", error);
          }
        }, 1500); // Wait a bit to ensure chart is ready
        
      } catch (error) {
        console.error("Failed to create chart instance:", error);
        
        // Try a more conservative fallback approach if the first attempt failed
        try {
          console.log("Attempting fallback chart creation with minimal configuration");
          
          // Create a minimal configuration without potentially problematic features
          const fallbackOptions = {
            ...chartOptions,
            stockTools: {
              gui: {
                enabled: false // Disable the stock tools GUI
              }
            }
          };
          
          // Try to create a chart without stock tools
          chartInstanceRef.current = highcharts.stockChart(chartRef.current, fallbackOptions);
          console.log("Fallback chart created successfully (without stock tools)");
          
        } catch (fallbackError) {
          console.error("Fallback chart creation also failed:", fallbackError);
        }
      }
    } else if (chartInstanceRef.current) {
      console.log("Updating existing chart");
      try {
        chartInstanceRef.current.update(chartOptions, true);
        console.log("Chart updated successfully");
      } catch (error) {
        console.error("Failed to update chart:", error);
      }
    }
    
    // Cleanup function to destroy chart when component unmounts
    return () => {
      if (chartInstanceRef.current) {
        console.log("Destroying chart instance");
        chartInstanceRef.current.destroy();
        chartInstanceRef.current = null;
      }
    };
  }, [chartOptions, highcharts]);

  // Replace the existing handleRatioChange with a new text-focused handler
  const handleRatioTextChange = (e) => {
    // Allow any text input without immediate validation
    setPriceToBarRatioText(e.target.value);
  };

  // Handle the blur event to apply the valid numeric value
  const handleRatioBlur = () => {
    const newValue = parseFloat(priceToBarRatioText);
    if (!isNaN(newValue) && newValue > 0) {
      setPriceToBarRatio(newValue);
    } else {
      // Reset text to match the current actual value
      setPriceToBarRatioText(priceToBarRatio.toString());
    }
  };

  // Optional: Add a handler for Enter key to apply the value immediately
  const handleRatioKeyDown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleRatioBlur();
      e.target.blur(); // Remove focus from the input
    }
  };

  // Function to toggle the ratio lock
  const toggleRatioLock = () => {
    const newState = !isRatioLocked;
    setIsRatioLocked(newState);
    
    console.log(`Price-to-bar ratio lock ${newState ? 'enabled' : 'disabled'}`);
    
    // If we're turning on locking, immediately apply the ratio constraint
    if (newState && chartInstanceRef.current) {
      try {
        const chart = chartInstanceRef.current;
        const xAxis = chart.xAxis[0];
        const yAxis = chart.yAxis[0];
        
        if (!xAxis || !yAxis) return;
        
        // Current X-axis range
        const currentXRange = xAxis.max - xAxis.min;
        
        // Calculate bars in view
        const dataStartDate = chart.series[0].xData[0];
        const dataEndDate = chart.series[0].xData[chart.series[0].xData.length - 1];
        const barsCount = chart.series[0].xData.length;
        const timePerBar = (dataEndDate - dataStartDate) / barsCount;
        const barsInView = Math.round(currentXRange / timePerBar);
        
        // Calculate Y-axis range based on price-to-bar ratio
        const newYRange = priceToBarRatio * barsInView;
        
        // Current center of Y-axis
        const centerY = (yAxis.max + yAxis.min) / 2;
        
        console.log("Applying initial ratio lock:", {
          barsInView,
          newYRange,
          centerY
        });
        
        // Update Y-axis extremes
        yAxis.setExtremes(
          centerY - newYRange / 2,
          centerY + newYRange / 2,
          true, // Animation
          true // Redraw immediately
        );
      } catch (error) {
        console.error("Error applying initial ratio lock:", error);
      }
    }
  };

  // If we're on the server or Highcharts isn't loaded, show a loading state
  if (!highcharts) {
    return (
      <div className="loading-chart">
        <p>Loading chart...</p>
        <style jsx>{`
          .loading-chart {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 400px;
            background-color: #f9f9f9;
            border-radius: 8px;
          }
        `}</style>
      </div>
    );
  }

  return (
    <div className="highstock-chart-container">
      <div className="chart-controls">
        <div className="ratio-control">
          <label htmlFor="price-bar-ratio">
            Price-to-Bar Ratio:
            <input
              id="price-bar-ratio"
              type="text"
              value={priceToBarRatioText}
              onChange={handleRatioTextChange}
              onBlur={handleRatioBlur}
              onKeyDown={handleRatioKeyDown}
              className="ratio-input"
            />
          </label>
          <button
            onClick={toggleRatioLock}
            className={`ratio-lock-button ${isRatioLocked ? 'locked' : 'unlocked'}`}
          >
            {isRatioLocked ? '🔒 Locked' : '🔓 Unlocked'}
          </button>
          <div className="ratio-info">
            <small>Try values between 0.1 and 3 for best results</small>
          </div>
        </div>
        <div className="ohlc-display" id="ohlc-display">
          <span>Hover over candle</span>
        </div>
        {drawnLineInfo && (
          <div className="drawn-line-info">
            <h4>Line Info</h4>
            <p>
              Start: ({drawnLineInfo.start.x.toFixed(2)}, {drawnLineInfo.start.y.toFixed(2)})
              <br />
              End: ({drawnLineInfo.end.x.toFixed(2)}, {drawnLineInfo.end.y.toFixed(2)})
              <br />
              Angle: {drawnLineInfo.angle}°
            </p>
          </div>
        )}
      </div>
      <div className="highcharts-stock-chart-wrapper">
        <div ref={chartRef} className="chart-container" />
      </div>
      
      <style jsx>{`
        .highstock-chart-container {
          width: 100%;
          padding: 20px;
          background-color: #fff;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .chart-controls {
          display: flex;
          justify-content: space-between;
          margin-bottom: 20px;
          flex-wrap: wrap;
          align-items: center;
        }
        
        .ratio-control {
          display: flex;
          align-items: center;
          gap: 10px;
          flex-wrap: wrap;
        }
        
        .ohlc-display {
          font-family: monospace;
          font-size: 13px;
          margin-left: 20px;
          padding: 8px 12px;
          border-left: 2px solid #eee;
          line-height: 1.5;
          flex-grow: 1;
          max-width: 400px;
        }
        
        .ratio-info {
          width: 100%;
          color: #666;
          margin-top: 4px;
        }
        
        .ratio-input {
          width: 120px;
          padding: 8px;
          border: 1px solid #ccc;
          border-radius: 4px;
        }
        
        .ratio-lock-button {
          padding: 8px 12px;
          background-color: #f0f0f0;
          border: 1px solid #ccc;
          border-radius: 4px;
          cursor: pointer;
          transition: background-color 0.2s;
        }
        
        .ratio-lock-button.locked {
          background-color: #e6f7ff;
          border-color: #1890ff;
          color: #1890ff;
        }
        
        .drawn-line-info {
          background-color: #f9f9f9;
          padding: 10px;
          border-radius: 4px;
          border-left: 3px solid #1890ff;
        }
        
        .drawn-line-info h4 {
          margin-top: 0;
          margin-bottom: 10px;
          font-family: monospace;
        }
        
        .drawn-line-info p {
          margin: 5px 0;
          font-family: monospace;
        }
        
        .highcharts-stock-chart-wrapper {
          position: relative;
          min-height: 600px;
        }
        
        .chart-container {
          position: relative;
          width: 100%;
          height: 600px;
        }
        
        /* Enhance the toolbar visibility styles */
        :global(.highcharts-stocktools-wrapper) {
          position: absolute !important;
          z-index: 100 !important;
          top: 0 !important;
          left: 0 !important;
          display: block !important;
          visibility: visible !important;
          opacity: 1 !important;
        }
        
        :global(.highcharts-stocktools-toolbar) {
          display: block !important;
          visibility: visible !important;
          opacity: 1 !important;
        }
        
        :global(.highcharts-stocktools-toolbar .highcharts-menu-item) {
          display: block !important;
        }
        
        :global(.highcharts-stocktools-toolbar .highcharts-menu-item-btn) {
          display: block !important;
        }
      `}</style>
    </div>
  );
};

HighstockTradingViewChart.propTypes = {
  data: PropTypes.array,
  title: PropTypes.string,
  initialPriceToBarRatio: PropTypes.number
};

// Export as dynamic component with SSR disabled to prevent loading Highcharts on server
export default dynamic(() => Promise.resolve(HighstockTradingViewChart), {
  ssr: false
}); 