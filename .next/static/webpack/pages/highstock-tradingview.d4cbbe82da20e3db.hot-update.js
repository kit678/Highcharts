"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/highstock-tradingview",{

/***/ "./utils/chartOptionsBuilder.js":
/*!**************************************!*\
  !*** ./utils/chartOptionsBuilder.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildChartOptions\": function() { return /* binding */ buildChartOptions; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/src/_to_consumable_array.mjs */ \"./node_modules/@swc/helpers/src/_to_consumable_array.mjs\");\n/* harmony import */ var _dataUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataUtils */ \"./utils/dataUtils.js\");\n\n\n/**\r\n * Build chart options object based on provided data and settings\r\n */ var buildChartOptions = function(data, param) {\n    var _title = param.title, title = _title === void 0 ? \"Price Chart\" : _title, _priceToBarRatio = param.priceToBarRatio, priceToBarRatio = _priceToBarRatio === void 0 ? 1 : _priceToBarRatio, _isRatioLocked = param.isRatioLocked, isRatioLocked = _isRatioLocked === void 0 ? false : _isRatioLocked, _onSetExtremes = param.onSetExtremes, onSetExtremes = _onSetExtremes === void 0 ? null : _onSetExtremes, _updateOHLCDisplay = param.updateOHLCDisplay, updateOHLCDisplay = _updateOHLCDisplay === void 0 ? null : _updateOHLCDisplay;\n    if (!data || data.length === 0) return null;\n    // Process data\n    var ohlcData = (0,_dataUtils__WEBPACK_IMPORTED_MODULE_0__.formatOHLCData)(data);\n    var volumeData = (0,_dataUtils__WEBPACK_IMPORTED_MODULE_0__.formatVolumeData)(data);\n    // Calculate axis ranges\n    var yAxisConfig = (0,_dataUtils__WEBPACK_IMPORTED_MODULE_0__.calculateYAxisRange)(data, priceToBarRatio);\n    // Date range info\n    var startDate = ohlcData[0][0];\n    var endDate = ohlcData[ohlcData.length - 1][0];\n    var timeRange = endDate - startDate;\n    // Core chart options structure\n    return {\n        chart: {\n            height: 600,\n            animation: false,\n            panning: {\n                enabled: true,\n                type: \"xy\"\n            },\n            panKey: undefined,\n            zoomType: undefined,\n            marginBottom: 100,\n            spacingBottom: 15,\n            events: {\n                load: function load() {\n                    console.log(\"\\uD83D\\uDD0D DEBUG: Chart load event triggered\");\n                    // Ensure zooming and ratio locking works with the initial view\n                    if (isRatioLocked && onSetExtremes) {\n                        try {\n                            var xAxis = this.xAxis[0];\n                            var extremes = {\n                                min: xAxis.min,\n                                max: xAxis.max\n                            };\n                            // Initialize the proper Y-axis range based on visible X range\n                            setTimeout(function() {\n                                return onSetExtremes(xAxis, extremes);\n                            }, 100);\n                        } catch (error) {\n                            console.error(\"Error applying initial ratio:\", error);\n                        }\n                    }\n                    console.log(\"\\uD83D\\uDD0D DEBUG: Chart initialized successfully\");\n                },\n                redraw: function redraw() {\n                    // Update OHLC display on redraw if callback provided\n                    if (updateOHLCDisplay && this.hoverPoints && this.hoverPoints[0]) {\n                        updateOHLCDisplay(this.hoverPoints[0]);\n                    }\n                }\n            }\n        },\n        // Range selector options\n        rangeSelector: {\n            enabled: true,\n            selected: 1,\n            buttons: [\n                {\n                    type: \"month\",\n                    count: 1,\n                    text: \"1m\"\n                },\n                {\n                    type: \"month\",\n                    count: 3,\n                    text: \"3m\"\n                },\n                {\n                    type: \"month\",\n                    count: 6,\n                    text: \"6m\"\n                },\n                {\n                    type: \"ytd\",\n                    text: \"YTD\"\n                },\n                {\n                    type: \"year\",\n                    count: 1,\n                    text: \"1y\"\n                },\n                {\n                    type: \"all\",\n                    text: \"All\"\n                }\n            ],\n            inputEnabled: true\n        },\n        // Navigator and scrollbar\n        navigator: {\n            enabled: true,\n            height: 50,\n            margin: 25\n        },\n        scrollbar: {\n            enabled: true,\n            margin: 8\n        },\n        // Chart title\n        title: {\n            text: title\n        },\n        // Plot styling\n        plotOptions: {\n            candlestick: {\n                // Restore original colors to maintain original appearance\n                color: \"#2f7ed8\",\n                upColor: \"white\",\n                lineColor: \"#2f7ed8\",\n                upLineColor: \"#2f7ed8\",\n                states: {\n                    hover: {\n                        brightness: 0.1\n                    }\n                },\n                // Ensure no gaps in data\n                gapSize: 0,\n                dataGrouping: {\n                    enabled: false // Disable data grouping for consistent display\n                }\n            },\n            series: {\n                pointPadding: 0.1,\n                groupPadding: 0.1,\n                borderWidth: 1,\n                dataGrouping: {\n                    enabled: false\n                },\n                clip: false\n            }\n        },\n        // Tooltip configuration\n        tooltip: {\n            enabled: true,\n            followPointer: true,\n            followTouchMove: true,\n            formatter: function formatter() {\n                if (!this.points || !this.points[0] || !this.points[0].point) return false;\n                // Update the OHLC display if callback provided\n                if (updateOHLCDisplay) {\n                    updateOHLCDisplay(this.points[0].point);\n                }\n                // Return false to prevent showing the tooltip\n                return false;\n            }\n        },\n        // X-axis configuration\n        xAxis: {\n            ordinal: false,\n            minRange: 24 * 3600 * 1000,\n            overscroll: 2,\n            min: null,\n            max: null,\n            maxPadding: 0.3,\n            minPadding: 0.05,\n            lineWidth: 1,\n            tickLength: 5,\n            margin: 10,\n            events: {\n                afterSetExtremes: function afterSetExtremes(e) {\n                    console.log(\"X-axis extremes changed:\", e.min, e.max);\n                    if (!isRatioLocked || !onSetExtremes) return;\n                    // Apply ratio lock when X-axis changes\n                    onSetExtremes(this, e);\n                },\n                setExtremes: function setExtremes(e) {\n                    // If ratio locked, we need to also listen for setExtremes (called before afterSetExtremes)\n                    if (isRatioLocked && e && e.trigger && e.trigger !== \"syncExtremes\") {\n                        console.log(\"X-axis setExtremes called:\", e.trigger);\n                    }\n                }\n            }\n        },\n        // Y-axis configuration\n        yAxis: [\n            {\n                // Price axis\n                min: null,\n                max: null,\n                startOnTick: false,\n                endOnTick: false,\n                minPadding: 0.2,\n                maxPadding: 0.2,\n                labels: {\n                    align: \"right\",\n                    x: -3\n                },\n                title: {\n                    text: \"Price\"\n                },\n                height: \"60%\",\n                lineWidth: 2,\n                resize: {\n                    enabled: true\n                },\n                softMin: yAxisConfig.min,\n                softMax: yAxisConfig.max,\n                showEmpty: false,\n                events: {\n                    afterSetExtremes: function afterSetExtremes(e) {\n                        console.log(\"Y-axis extremes changed:\", e.min, e.max);\n                        if (!isRatioLocked || !onSetExtremes) return;\n                        // Only apply ratio lock when Y-axis changes directly (not as result of X change)\n                        if (e.trigger && e.trigger !== \"syncExtremes\") {\n                            onSetExtremes(this, e);\n                        }\n                    }\n                }\n            },\n            {\n                // Volume axis\n                labels: {\n                    align: \"right\",\n                    x: -3\n                },\n                title: {\n                    text: \"Volume\"\n                },\n                top: \"65%\",\n                height: \"35%\",\n                offset: 0,\n                lineWidth: 2,\n                min: null,\n                max: null,\n                minPadding: 0.2,\n                maxPadding: 0.2,\n                showEmpty: false\n            }\n        ],\n        // Series data\n        series: [\n            // Main price series\n            {\n                type: \"candlestick\",\n                name: \"Price\",\n                id: \"price_chart\",\n                data: ohlcData,\n                dataGrouping: {\n                    enabled: false\n                },\n                // Colors to match original appearance\n                color: \"#2f7ed8\",\n                upColor: \"white\",\n                lineColor: \"#2f7ed8\",\n                upLineColor: \"#2f7ed8\" // Up candle border\n            }\n        ].concat(// Add volume series if available\n        (0,_swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(volumeData.length > 0 ? [\n            {\n                type: \"column\",\n                name: \"Volume\",\n                id: \"volume_chart\",\n                data: volumeData,\n                yAxis: 1,\n                color: \"rgba(100, 100, 255, 0.5)\"\n            }\n        ] : []))\n    };\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E4QjtnQkFDQUMsT0FBTyxFQUFFLE9BQU87Z0JBQ2hCQyxTQUFTLEVBQUU7Z0JBQ1hDLFdBQVcsRUFBRTthQUNkO1NBVUYsQ0F2Qk8sTUF1QlAsQ0FUQyxpQ0FBaUM7UUFDakM7WUFBNkI7NEZBQ3JCLEVBQVE7O2dCQUVkeUMsRUFBRSxFQUFFO2dCQUNKM0YsSUFBSSxFQUFFUTtnQkFDTnNFLEtBQUssRUFBRSxDQUFDO2dCQUNSL0IsS0FBSyxFQUFFO2FBQ1I7U0FBQyxHQUFHLEVBQUUsQ0FQSixDQVFKO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9jaGFydE9wdGlvbnNCdWlsZGVyLmpzP2JlY2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0T0hMQ0RhdGEsIGZvcm1hdFZvbHVtZURhdGEsIGNhbGN1bGF0ZVlBeGlzUmFuZ2UgfSBmcm9tICcuL2RhdGFVdGlscyc7XHJcblxyXG4vKipcclxuICogQnVpbGQgY2hhcnQgb3B0aW9ucyBvYmplY3QgYmFzZWQgb24gcHJvdmlkZWQgZGF0YSBhbmQgc2V0dGluZ3NcclxuICovXHJcbmNvbnN0IGJ1aWxkQ2hhcnRPcHRpb25zID0gKGRhdGEsIHsgXHJcbiAgdGl0bGUgPSAnUHJpY2UgQ2hhcnQnLCBcclxuICBwcmljZVRvQmFyUmF0aW8gPSAxLFxyXG4gIGlzUmF0aW9Mb2NrZWQgPSBmYWxzZSxcclxuICBvblNldEV4dHJlbWVzID0gbnVsbCxcclxuICB1cGRhdGVPSExDRGlzcGxheSA9IG51bGxcclxufSkgPT4ge1xyXG4gIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XHJcbiAgXHJcbiAgLy8gUHJvY2VzcyBkYXRhXHJcbiAgY29uc3Qgb2hsY0RhdGEgPSBmb3JtYXRPSExDRGF0YShkYXRhKTtcclxuICBjb25zdCB2b2x1bWVEYXRhID0gZm9ybWF0Vm9sdW1lRGF0YShkYXRhKTtcclxuICBcclxuICAvLyBDYWxjdWxhdGUgYXhpcyByYW5nZXNcclxuICBjb25zdCB5QXhpc0NvbmZpZyA9IGNhbGN1bGF0ZVlBeGlzUmFuZ2UoZGF0YSwgcHJpY2VUb0JhclJhdGlvKTtcclxuICBcclxuICAvLyBEYXRlIHJhbmdlIGluZm9cclxuICBjb25zdCBzdGFydERhdGUgPSBvaGxjRGF0YVswXVswXTtcclxuICBjb25zdCBlbmREYXRlID0gb2hsY0RhdGFbb2hsY0RhdGEubGVuZ3RoIC0gMV1bMF07XHJcbiAgY29uc3QgdGltZVJhbmdlID0gZW5kRGF0ZSAtIHN0YXJ0RGF0ZTtcclxuICBcclxuICAvLyBDb3JlIGNoYXJ0IG9wdGlvbnMgc3RydWN0dXJlXHJcbiAgcmV0dXJuIHtcclxuICAgIGNoYXJ0OiB7XHJcbiAgICAgIGhlaWdodDogNjAwLFxyXG4gICAgICBhbmltYXRpb246IGZhbHNlLFxyXG4gICAgICBwYW5uaW5nOiB7XHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICB0eXBlOiAneHknXHJcbiAgICAgIH0sXHJcbiAgICAgIHBhbktleTogdW5kZWZpbmVkLFxyXG4gICAgICB6b29tVHlwZTogdW5kZWZpbmVkLFxyXG4gICAgICBtYXJnaW5Cb3R0b206IDEwMCxcclxuICAgICAgc3BhY2luZ0JvdHRvbTogMTUsXHJcbiAgICAgIGV2ZW50czoge1xyXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIERFQlVHOiBDaGFydCBsb2FkIGV2ZW50IHRyaWdnZXJlZFwiKTtcclxuICAgICAgICAgIC8vIEVuc3VyZSB6b29taW5nIGFuZCByYXRpbyBsb2NraW5nIHdvcmtzIHdpdGggdGhlIGluaXRpYWwgdmlld1xyXG4gICAgICAgICAgaWYgKGlzUmF0aW9Mb2NrZWQgJiYgb25TZXRFeHRyZW1lcykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy54QXhpc1swXTtcclxuICAgICAgICAgICAgICBjb25zdCBleHRyZW1lcyA9IHtcclxuICAgICAgICAgICAgICAgIG1pbjogeEF4aXMubWluLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB4QXhpcy5tYXhcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHByb3BlciBZLWF4aXMgcmFuZ2UgYmFzZWQgb24gdmlzaWJsZSBYIHJhbmdlXHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvblNldEV4dHJlbWVzKHhBeGlzLCBleHRyZW1lcyksIDEwMCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFwcGx5aW5nIGluaXRpYWwgcmF0aW86XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gREVCVUc6IENoYXJ0IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZHJhdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgT0hMQyBkaXNwbGF5IG9uIHJlZHJhdyBpZiBjYWxsYmFjayBwcm92aWRlZFxyXG4gICAgICAgICAgaWYgKHVwZGF0ZU9ITENEaXNwbGF5ICYmIHRoaXMuaG92ZXJQb2ludHMgJiYgdGhpcy5ob3ZlclBvaW50c1swXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVPSExDRGlzcGxheSh0aGlzLmhvdmVyUG9pbnRzWzBdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vIFJhbmdlIHNlbGVjdG9yIG9wdGlvbnNcclxuICAgIHJhbmdlU2VsZWN0b3I6IHtcclxuICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgc2VsZWN0ZWQ6IDEsXHJcbiAgICAgIGJ1dHRvbnM6IFt7XHJcbiAgICAgICAgdHlwZTogJ21vbnRoJyxcclxuICAgICAgICBjb3VudDogMSxcclxuICAgICAgICB0ZXh0OiAnMW0nXHJcbiAgICAgIH0sIHtcclxuICAgICAgICB0eXBlOiAnbW9udGgnLFxyXG4gICAgICAgIGNvdW50OiAzLFxyXG4gICAgICAgIHRleHQ6ICczbSdcclxuICAgICAgfSwge1xyXG4gICAgICAgIHR5cGU6ICdtb250aCcsXHJcbiAgICAgICAgY291bnQ6IDYsXHJcbiAgICAgICAgdGV4dDogJzZtJ1xyXG4gICAgICB9LCB7XHJcbiAgICAgICAgdHlwZTogJ3l0ZCcsXHJcbiAgICAgICAgdGV4dDogJ1lURCdcclxuICAgICAgfSwge1xyXG4gICAgICAgIHR5cGU6ICd5ZWFyJyxcclxuICAgICAgICBjb3VudDogMSxcclxuICAgICAgICB0ZXh0OiAnMXknXHJcbiAgICAgIH0sIHtcclxuICAgICAgICB0eXBlOiAnYWxsJyxcclxuICAgICAgICB0ZXh0OiAnQWxsJ1xyXG4gICAgICB9XSxcclxuICAgICAgaW5wdXRFbmFibGVkOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBOYXZpZ2F0b3IgYW5kIHNjcm9sbGJhclxyXG4gICAgbmF2aWdhdG9yOiB7IFxyXG4gICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICBoZWlnaHQ6IDUwLFxyXG4gICAgICBtYXJnaW46IDI1XHJcbiAgICB9LFxyXG4gICAgc2Nyb2xsYmFyOiB7IFxyXG4gICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICBtYXJnaW46IDhcclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vIENoYXJ0IHRpdGxlXHJcbiAgICB0aXRsZTogeyB0ZXh0OiB0aXRsZSB9LFxyXG4gICAgXHJcbiAgICAvLyBQbG90IHN0eWxpbmdcclxuICAgIHBsb3RPcHRpb25zOiB7XHJcbiAgICAgIGNhbmRsZXN0aWNrOiB7XHJcbiAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvcnMgdG8gbWFpbnRhaW4gb3JpZ2luYWwgYXBwZWFyYW5jZVxyXG4gICAgICAgIGNvbG9yOiAnIzJmN2VkOCcsICAgICAgLy8gRG93biBjYW5kbGVcclxuICAgICAgICB1cENvbG9yOiAnd2hpdGUnLCAgICAgIC8vIFVwIGNhbmRsZSBcclxuICAgICAgICBsaW5lQ29sb3I6ICcjMmY3ZWQ4JywgIC8vIERvd24gY2FuZGxlIGJvcmRlclxyXG4gICAgICAgIHVwTGluZUNvbG9yOiAnIzJmN2VkOCcsIC8vIFVwIGNhbmRsZSBib3JkZXJcclxuICAgICAgICBzdGF0ZXM6IHtcclxuICAgICAgICAgIGhvdmVyOiB7IGJyaWdodG5lc3M6IDAuMSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBFbnN1cmUgbm8gZ2FwcyBpbiBkYXRhXHJcbiAgICAgICAgZ2FwU2l6ZTogMCxcclxuICAgICAgICBkYXRhR3JvdXBpbmc6IHtcclxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlICAvLyBEaXNhYmxlIGRhdGEgZ3JvdXBpbmcgZm9yIGNvbnNpc3RlbnQgZGlzcGxheVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgc2VyaWVzOiB7XHJcbiAgICAgICAgcG9pbnRQYWRkaW5nOiAwLjEsXHJcbiAgICAgICAgZ3JvdXBQYWRkaW5nOiAwLjEsXHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXHJcbiAgICAgICAgZGF0YUdyb3VwaW5nOiB7XHJcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2xpcDogZmFsc2VcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy8gVG9vbHRpcCBjb25maWd1cmF0aW9uXHJcbiAgICB0b29sdGlwOiB7XHJcbiAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgIGZvbGxvd1BvaW50ZXI6IHRydWUsXHJcbiAgICAgIGZvbGxvd1RvdWNoTW92ZTogdHJ1ZSxcclxuICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMucG9pbnRzIHx8ICF0aGlzLnBvaW50c1swXSB8fCAhdGhpcy5wb2ludHNbMF0ucG9pbnQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIE9ITEMgZGlzcGxheSBpZiBjYWxsYmFjayBwcm92aWRlZFxyXG4gICAgICAgIGlmICh1cGRhdGVPSExDRGlzcGxheSkge1xyXG4gICAgICAgICAgdXBkYXRlT0hMQ0Rpc3BsYXkodGhpcy5wb2ludHNbMF0ucG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gcHJldmVudCBzaG93aW5nIHRoZSB0b29sdGlwXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBYLWF4aXMgY29uZmlndXJhdGlvblxyXG4gICAgeEF4aXM6IHtcclxuICAgICAgb3JkaW5hbDogZmFsc2UsICAgICAgLy8gSW1wb3J0YW50IC0gZGlzYWJsZSBvcmRpbmFsIGF4aXMgdG8gcHJlc2VydmUgdGltZSBzY2FsZVxyXG4gICAgICBtaW5SYW5nZTogMjQgKiAzNjAwICogMTAwMCxcclxuICAgICAgb3ZlcnNjcm9sbDogMiwgICAgICAgLy8gSW5jcmVhc2Ugb3ZlcnNjcm9sbCBmb3IgbW9yZSBzcGFjZSB0byB0aGUgcmlnaHRcclxuICAgICAgbWluOiBudWxsLCAgICAgICAgICAgLy8gQWxsb3cgcGFubmluZyBiZXlvbmQgdGhlIGZpcnN0IHBvaW50XHJcbiAgICAgIG1heDogbnVsbCwgICAgICAgICAgIC8vIEFsbG93IHBhbm5pbmcgYmV5b25kIHRoZSBsYXN0IHBvaW50IFxyXG4gICAgICBtYXhQYWRkaW5nOiAwLjMsICAgICAvLyBBZGQgbW9yZSBwYWRkaW5nIHRvIHRoZSByaWdodFxyXG4gICAgICBtaW5QYWRkaW5nOiAwLjA1LCAgICAvLyBBZGQgc29tZSBwYWRkaW5nIHRvIHRoZSBsZWZ0XHJcbiAgICAgIGxpbmVXaWR0aDogMSxcclxuICAgICAgdGlja0xlbmd0aDogNSxcclxuICAgICAgbWFyZ2luOiAxMCxcclxuICAgICAgZXZlbnRzOiB7XHJcbiAgICAgICAgYWZ0ZXJTZXRFeHRyZW1lczogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJYLWF4aXMgZXh0cmVtZXMgY2hhbmdlZDpcIiwgZS5taW4sIGUubWF4KTtcclxuICAgICAgICAgIGlmICghaXNSYXRpb0xvY2tlZCB8fCAhb25TZXRFeHRyZW1lcykgcmV0dXJuO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBBcHBseSByYXRpbyBsb2NrIHdoZW4gWC1heGlzIGNoYW5nZXNcclxuICAgICAgICAgIG9uU2V0RXh0cmVtZXModGhpcywgZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRFeHRyZW1lczogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgLy8gSWYgcmF0aW8gbG9ja2VkLCB3ZSBuZWVkIHRvIGFsc28gbGlzdGVuIGZvciBzZXRFeHRyZW1lcyAoY2FsbGVkIGJlZm9yZSBhZnRlclNldEV4dHJlbWVzKVxyXG4gICAgICAgICAgaWYgKGlzUmF0aW9Mb2NrZWQgJiYgZSAmJiBlLnRyaWdnZXIgJiYgZS50cmlnZ2VyICE9PSAnc3luY0V4dHJlbWVzJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlgtYXhpcyBzZXRFeHRyZW1lcyBjYWxsZWQ6XCIsIGUudHJpZ2dlcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBZLWF4aXMgY29uZmlndXJhdGlvblxyXG4gICAgeUF4aXM6IFt7XHJcbiAgICAgIC8vIFByaWNlIGF4aXNcclxuICAgICAgbWluOiBudWxsLCAgICAgICAgICAgLy8gQWxsb3cgcGFubmluZyBiZWxvdyB0aGUgbG93ZXN0IHByaWNlXHJcbiAgICAgIG1heDogbnVsbCwgICAgICAgICAgIC8vIEFsbG93IHBhbm5pbmcgYWJvdmUgdGhlIGhpZ2hlc3QgcHJpY2VcclxuICAgICAgc3RhcnRPblRpY2s6IGZhbHNlLFxyXG4gICAgICBlbmRPblRpY2s6IGZhbHNlLFxyXG4gICAgICBtaW5QYWRkaW5nOiAwLjIsICAgICAvLyBJbmNyZWFzZSBwYWRkaW5nIGJlbG93XHJcbiAgICAgIG1heFBhZGRpbmc6IDAuMiwgICAgIC8vIEluY3JlYXNlIHBhZGRpbmcgYWJvdmVcclxuICAgICAgbGFiZWxzOiB7IGFsaWduOiAncmlnaHQnLCB4OiAtMyB9LFxyXG4gICAgICB0aXRsZTogeyB0ZXh0OiAnUHJpY2UnIH0sXHJcbiAgICAgIGhlaWdodDogJzYwJScsXHJcbiAgICAgIGxpbmVXaWR0aDogMixcclxuICAgICAgcmVzaXplOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuICAgICAgc29mdE1pbjogeUF4aXNDb25maWcubWluLCAgLy8gU29mdCBtaW5pbXVtIGZvciBpbml0aWFsIHZpZXdcclxuICAgICAgc29mdE1heDogeUF4aXNDb25maWcubWF4LCAgLy8gU29mdCBtYXhpbXVtIGZvciBpbml0aWFsIHZpZXdcclxuICAgICAgc2hvd0VtcHR5OiBmYWxzZSxcclxuICAgICAgZXZlbnRzOiB7XHJcbiAgICAgICAgYWZ0ZXJTZXRFeHRyZW1lczogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJZLWF4aXMgZXh0cmVtZXMgY2hhbmdlZDpcIiwgZS5taW4sIGUubWF4KTtcclxuICAgICAgICAgIGlmICghaXNSYXRpb0xvY2tlZCB8fCAhb25TZXRFeHRyZW1lcykgcmV0dXJuO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBPbmx5IGFwcGx5IHJhdGlvIGxvY2sgd2hlbiBZLWF4aXMgY2hhbmdlcyBkaXJlY3RseSAobm90IGFzIHJlc3VsdCBvZiBYIGNoYW5nZSlcclxuICAgICAgICAgIGlmIChlLnRyaWdnZXIgJiYgZS50cmlnZ2VyICE9PSAnc3luY0V4dHJlbWVzJykge1xyXG4gICAgICAgICAgICBvblNldEV4dHJlbWVzKHRoaXMsIGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSwge1xyXG4gICAgICAvLyBWb2x1bWUgYXhpc1xyXG4gICAgICBsYWJlbHM6IHsgYWxpZ246ICdyaWdodCcsIHg6IC0zIH0sXHJcbiAgICAgIHRpdGxlOiB7IHRleHQ6ICdWb2x1bWUnIH0sXHJcbiAgICAgIHRvcDogJzY1JScsXHJcbiAgICAgIGhlaWdodDogJzM1JScsXHJcbiAgICAgIG9mZnNldDogMCxcclxuICAgICAgbGluZVdpZHRoOiAyLFxyXG4gICAgICBtaW46IG51bGwsICAgICAgICAgIC8vIEFsbG93IHBhbm5pbmcgYmVsb3cgdGhlIGxvd2VzdCB2b2x1bWVcclxuICAgICAgbWF4OiBudWxsLCAgICAgICAgICAvLyBBbGxvdyBwYW5uaW5nIGFib3ZlIHRoZSBoaWdoZXN0IHZvbHVtZVxyXG4gICAgICBtaW5QYWRkaW5nOiAwLjIsICAgIC8vIEFkZCBwYWRkaW5nIGJlbG93XHJcbiAgICAgIG1heFBhZGRpbmc6IDAuMiwgICAgLy8gQWRkIHBhZGRpbmcgYWJvdmVcclxuICAgICAgc2hvd0VtcHR5OiBmYWxzZVxyXG4gICAgfV0sXHJcbiAgICBcclxuICAgIC8vIFNlcmllcyBkYXRhXHJcbiAgICBzZXJpZXM6IFtcclxuICAgICAgLy8gTWFpbiBwcmljZSBzZXJpZXNcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdjYW5kbGVzdGljaycsXHJcbiAgICAgICAgbmFtZTogJ1ByaWNlJyxcclxuICAgICAgICBpZDogJ3ByaWNlX2NoYXJ0JyxcclxuICAgICAgICBkYXRhOiBvaGxjRGF0YSxcclxuICAgICAgICBkYXRhR3JvdXBpbmc6IHsgZW5hYmxlZDogZmFsc2UgfSxcclxuICAgICAgICAvLyBDb2xvcnMgdG8gbWF0Y2ggb3JpZ2luYWwgYXBwZWFyYW5jZVxyXG4gICAgICAgIGNvbG9yOiAnIzJmN2VkOCcsICAgICAgLy8gRG93biBjYW5kbGVcclxuICAgICAgICB1cENvbG9yOiAnd2hpdGUnLCAgICAgIC8vIFVwIGNhbmRsZSBcclxuICAgICAgICBsaW5lQ29sb3I6ICcjMmY3ZWQ4JywgIC8vIERvd24gY2FuZGxlIGJvcmRlclxyXG4gICAgICAgIHVwTGluZUNvbG9yOiAnIzJmN2VkOCcgLy8gVXAgY2FuZGxlIGJvcmRlclxyXG4gICAgICB9LFxyXG4gICAgICAvLyBBZGQgdm9sdW1lIHNlcmllcyBpZiBhdmFpbGFibGVcclxuICAgICAgLi4uKHZvbHVtZURhdGEubGVuZ3RoID4gMCA/IFt7XHJcbiAgICAgICAgdHlwZTogJ2NvbHVtbicsXHJcbiAgICAgICAgbmFtZTogJ1ZvbHVtZScsXHJcbiAgICAgICAgaWQ6ICd2b2x1bWVfY2hhcnQnLFxyXG4gICAgICAgIGRhdGE6IHZvbHVtZURhdGEsXHJcbiAgICAgICAgeUF4aXM6IDEsXHJcbiAgICAgICAgY29sb3I6ICdyZ2JhKDEwMCwgMTAwLCAyNTUsIDAuNSknXHJcbiAgICAgIH1dIDogW10pXHJcbiAgICBdXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCB7IGJ1aWxkQ2hhcnRPcHRpb25zIH07ICJdLCJuYW1lcyI6WyJmb3JtYXRPSExDRGF0YSIsImZvcm1hdFZvbHVtZURhdGEiLCJjYWxjdWxhdGVZQXhpc1JhbmdlIiwiYnVpbGRDaGFydE9wdGlvbnMiLCJkYXRhIiwidGl0bGUiLCJwcmljZVRvQmFyUmF0aW8iLCJpc1JhdGlvTG9ja2VkIiwib25TZXRFeHRyZW1lcyIsInVwZGF0ZU9ITENEaXNwbGF5IiwibGVuZ3RoIiwib2hsY0RhdGEiLCJ2b2x1bWVEYXRhIiwieUF4aXNDb25maWciLCJzdGFydERhdGUiLCJlbmREYXRlIiwidGltZVJhbmdlIiwiY2hhcnQiLCJoZWlnaHQiLCJhbmltYXRpb24iLCJwYW5uaW5nIiwiZW5hYmxlZCIsInR5cGUiLCJwYW5LZXkiLCJ1bmRlZmluZWQiLCJ6b29tVHlwZSIsIm1hcmdpbkJvdHRvbSIsInNwYWNpbmdCb3R0b20iLCJldmVudHMiLCJsb2FkIiwiY29uc29sZSIsImxvZyIsInhBeGlzIiwiZXh0cmVtZXMiLCJtaW4iLCJtYXgiLCJzZXRUaW1lb3V0IiwiZXJyb3IiLCJyZWRyYXciLCJob3ZlclBvaW50cyIsInJhbmdlU2VsZWN0b3IiLCJzZWxlY3RlZCIsImJ1dHRvbnMiLCJjb3VudCIsInRleHQiLCJpbnB1dEVuYWJsZWQiLCJuYXZpZ2F0b3IiLCJtYXJnaW4iLCJzY3JvbGxiYXIiLCJwbG90T3B0aW9ucyIsImNhbmRsZXN0aWNrIiwiY29sb3IiLCJ1cENvbG9yIiwibGluZUNvbG9yIiwidXBMaW5lQ29sb3IiLCJzdGF0ZXMiLCJob3ZlciIsImJyaWdodG5lc3MiLCJnYXBTaXplIiwiZGF0YUdyb3VwaW5nIiwic2VyaWVzIiwicG9pbnRQYWRkaW5nIiwiZ3JvdXBQYWRkaW5nIiwiYm9yZGVyV2lkdGgiLCJjbGlwIiwidG9vbHRpcCIsImZvbGxvd1BvaW50ZXIiLCJmb2xsb3dUb3VjaE1vdmUiLCJmb3JtYXR0ZXIiLCJwb2ludHMiLCJwb2ludCIsIm9yZGluYWwiLCJtaW5SYW5nZSIsIm92ZXJzY3JvbGwiLCJtYXhQYWRkaW5nIiwibWluUGFkZGluZyIsImxpbmVXaWR0aCIsInRpY2tMZW5ndGgiLCJhZnRlclNldEV4dHJlbWVzIiwiZSIsInNldEV4dHJlbWVzIiwidHJpZ2dlciIsInlBeGlzIiwic3RhcnRPblRpY2siLCJlbmRPblRpY2siLCJsYWJlbHMiLCJhbGlnbiIsIngiLCJyZXNpemUiLCJzb2Z0TWluIiwic29mdE1heCIsInNob3dFbXB0eSIsInRvcCIsIm9mZnNldCIsIm5hbWUiLCJpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/chartOptionsBuilder.js\n"));

/***/ })

});