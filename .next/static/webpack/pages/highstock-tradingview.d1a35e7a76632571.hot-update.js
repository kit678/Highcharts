"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/highstock-tradingview",{

/***/ "./utils/chartOptionsBuilder.js":
/*!**************************************!*\
  !*** ./utils/chartOptionsBuilder.js ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"buildChartOptions\": function() { return /* binding */ buildChartOptions; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @swc/helpers/src/_to_consumable_array.mjs */ \"./node_modules/@swc/helpers/src/_to_consumable_array.mjs\");\n/* harmony import */ var _dataUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dataUtils */ \"./utils/dataUtils.js\");\n\n\n/**\r\n * Build chart options object based on provided data and settings\r\n */ var buildChartOptions = function(data, param) {\n    var _title = param.title, title = _title === void 0 ? \"Price Chart\" : _title, _priceToBarRatio = param.priceToBarRatio, priceToBarRatio = _priceToBarRatio === void 0 ? 0.00369 : _priceToBarRatio, _isRatioLocked = param.isRatioLocked, isRatioLocked = _isRatioLocked === void 0 ? true : _isRatioLocked, _onSetExtremes = param.onSetExtremes, onSetExtremes = _onSetExtremes === void 0 ? null : _onSetExtremes, _updateOHLCDisplay = param.updateOHLCDisplay, updateOHLCDisplay = _updateOHLCDisplay === void 0 ? null : _updateOHLCDisplay;\n    if (!data || data.length === 0) return null;\n    // Process data\n    var ohlcData = (0,_dataUtils__WEBPACK_IMPORTED_MODULE_0__.formatOHLCData)(data);\n    var volumeData = (0,_dataUtils__WEBPACK_IMPORTED_MODULE_0__.formatVolumeData)(data);\n    // Calculate axis ranges\n    var yAxisConfig = (0,_dataUtils__WEBPACK_IMPORTED_MODULE_0__.calculateYAxisRange)(data, priceToBarRatio);\n    // Date range info\n    var startDate = ohlcData[0][0];\n    var endDate = ohlcData[ohlcData.length - 1][0];\n    var timeRange = endDate - startDate;\n    // Core chart options structure\n    return {\n        chart: {\n            height: 600,\n            animation: false,\n            panning: {\n                enabled: true,\n                type: \"xy\"\n            },\n            zoomType: null,\n            events: {\n                load: function load() {\n                    console.log(\"\\uD83D\\uDD0D DEBUG: Chart load event triggered\");\n                    // Ensure zooming and ratio locking works with the initial view\n                    if (isRatioLocked && onSetExtremes) {\n                        try {\n                            var xAxis = this.xAxis[0];\n                            var extremes = {\n                                min: xAxis.min,\n                                max: xAxis.max\n                            };\n                            // Initialize the proper Y-axis range based on visible X range\n                            setTimeout(function() {\n                                return onSetExtremes(xAxis, extremes);\n                            }, 100);\n                        } catch (error) {\n                            console.error(\"Error applying initial ratio:\", error);\n                        }\n                    }\n                    console.log(\"\\uD83D\\uDD0D DEBUG: Chart initialized successfully\");\n                },\n                redraw: function redraw() {\n                    // Update OHLC display on redraw if callback provided\n                    if (updateOHLCDisplay && this.hoverPoints && this.hoverPoints[0]) {\n                        updateOHLCDisplay(this.hoverPoints[0]);\n                    }\n                }\n            }\n        },\n        // Range selector options\n        rangeSelector: {\n            enabled: true,\n            selected: 1,\n            buttons: [\n                {\n                    type: \"month\",\n                    count: 1,\n                    text: \"1m\"\n                },\n                {\n                    type: \"month\",\n                    count: 3,\n                    text: \"3m\"\n                },\n                {\n                    type: \"month\",\n                    count: 6,\n                    text: \"6m\"\n                },\n                {\n                    type: \"ytd\",\n                    text: \"YTD\"\n                },\n                {\n                    type: \"year\",\n                    count: 1,\n                    text: \"1y\"\n                },\n                {\n                    type: \"all\",\n                    text: \"All\"\n                }\n            ],\n            inputEnabled: true\n        },\n        // Navigator and scrollbar\n        navigator: {\n            enabled: true\n        },\n        scrollbar: {\n            enabled: true\n        },\n        // Chart title\n        title: {\n            text: title\n        },\n        // Plot styling\n        plotOptions: {\n            candlestick: {\n                // Restore original colors to maintain original appearance\n                color: \"#2f7ed8\",\n                upColor: \"white\",\n                lineColor: \"#2f7ed8\",\n                upLineColor: \"#2f7ed8\",\n                states: {\n                    hover: {\n                        brightness: 0.1\n                    }\n                },\n                // Ensure no gaps in data\n                gapSize: 0,\n                dataGrouping: {\n                    enabled: false // Disable data grouping for consistent display\n                }\n            },\n            series: {\n                pointPadding: 0.1,\n                groupPadding: 0.1,\n                borderWidth: 1,\n                dataGrouping: {\n                    enabled: false\n                }\n            }\n        },\n        // Tooltip configuration\n        tooltip: {\n            enabled: true,\n            followPointer: true,\n            followTouchMove: true,\n            formatter: function formatter() {\n                if (!this.points || !this.points[0] || !this.points[0].point) return false;\n                // Update the OHLC display if callback provided\n                if (updateOHLCDisplay) {\n                    updateOHLCDisplay(this.points[0].point);\n                }\n                // Return false to prevent showing the tooltip\n                return false;\n            }\n        },\n        // X-axis configuration\n        xAxis: {\n            ordinal: false,\n            minRange: 24 * 3600 * 1000,\n            overscroll: 0.5,\n            events: {\n                afterSetExtremes: function afterSetExtremes(e) {\n                    console.log(\"X-axis extremes changed:\", e.min, e.max);\n                    if (!isRatioLocked || !onSetExtremes) return;\n                    // Apply ratio lock when X-axis changes\n                    onSetExtremes(this, e);\n                },\n                setExtremes: function setExtremes(e) {\n                    // If ratio locked, we need to also listen for setExtremes (called before afterSetExtremes)\n                    if (isRatioLocked && e && e.trigger && e.trigger !== \"syncExtremes\") {\n                        console.log(\"X-axis setExtremes called:\", e.trigger);\n                    }\n                }\n            }\n        },\n        // Y-axis configuration\n        yAxis: [\n            {\n                // Price axis\n                min: yAxisConfig.min,\n                max: yAxisConfig.max,\n                startOnTick: false,\n                endOnTick: false,\n                minPadding: 0.1,\n                maxPadding: 0.1,\n                labels: {\n                    align: \"right\",\n                    x: -3\n                },\n                title: {\n                    text: \"Price\"\n                },\n                height: \"60%\",\n                lineWidth: 2,\n                resize: {\n                    enabled: true\n                },\n                events: {\n                    afterSetExtremes: function afterSetExtremes(e) {\n                        console.log(\"Y-axis extremes changed:\", e.min, e.max);\n                        if (!isRatioLocked || !onSetExtremes) return;\n                        // Only apply ratio lock when Y-axis changes directly (not as result of X change)\n                        if (e.trigger && e.trigger !== \"syncExtremes\") {\n                            onSetExtremes(this, e);\n                        }\n                    }\n                }\n            },\n            {\n                // Volume axis\n                labels: {\n                    align: \"right\",\n                    x: -3\n                },\n                title: {\n                    text: \"Volume\"\n                },\n                top: \"65%\",\n                height: \"35%\",\n                offset: 0,\n                lineWidth: 2\n            }\n        ],\n        // Series data\n        series: [\n            {\n                type: \"candlestick\",\n                name: \"Price\",\n                id: \"price_chart\",\n                data: ohlcData,\n                dataGrouping: {\n                    enabled: false\n                },\n                // Colors to match original appearance\n                color: \"#2f7ed8\",\n                upColor: \"white\",\n                lineColor: \"#2f7ed8\",\n                upLineColor: \"#2f7ed8\" // Up candle border\n            }\n        ].concat(// Add volume series if available\n        (0,_swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(volumeData.length > 0 ? [\n            {\n                type: \"column\",\n                name: \"Volume\",\n                id: \"volume_chart\",\n                data: volumeData,\n                yAxis: 1,\n                color: \"rgba(100, 100, 255, 0.5)\"\n            }\n        ] : []))\n    };\n};\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUU7O3dCQUVKRTt3QkFDQSxJQUFJLENBQUNuQixhQUFhLElBQUksQ0FBQ0MsYUFBYSxFQUFFO3dCQUV0Qzt3QkFDQSxJQUFJNkQsQ0FBQyxDQUFDRSxPQUFPLElBQUlGLENBQUMsQ0FBQ0UsT0FBTyxLQUFLLGNBQWM7NEJBQzNDL0QsYUFBYSxDQUFDLElBQUksRUFBRTZELENBQUMsQ0FBQyxDQUFDO3dCQUN6QixDQUFDO29CQUNILENBQUM7aUJBQ0Y7YUFDRjtZQUFFOzs7b0JBRVNTLEtBQUssRUFBRTtvQkFBU0MsQ0FBQyxFQUFFLENBQUMsQ0FBQztpQkFBRTtnQkFDakMxRSxLQUFLLEVBQUU7O2lCQUFrQjtnQkFDekI2RSxHQUFHLEVBQUUsS0FBSztnQkFDVmhFO2dCQUNBaUUsTUFBTSxFQUFFLENBQUM7Z0JBQ1RILFNBQVMsRUFBRSxDQUFDO2FBQ2I7U0FBQztRQUVGO1FBQ0F6QjtZQUNFO2dCQUNFakM7O2dCQUVBK0QsRUFBRSxFQUFFLGFBQWE7Z0JBQ2pCakYsSUFBSSxFQUFFTyxRQUFRO2dCQUNkMkMsWUFBWSxFQUFFO29CQUFFakMsT0FBTyxFQUFFO2lCQUFPO2dCQUNoQztnQkFDQXlCO2dCQUNBQyxPQUFPLEVBQUUsT0FBTztnQkFDaEJDLFNBQVMsRUFBRTtnQkFDWEMsV0FBVyxFQUFFO2FBQ2Q7U0FVRixDQXRCTyxNQXNCUCxDQVRDLGlDQUFpQztRQUNqQztZQUE2Qjs0RkFDckIsRUFBUTs7Z0JBRWRvQyxFQUFFLEVBQUU7Z0JBQ0pqRixJQUFJLEVBQUVRO2dCQUNONEQsS0FBSyxFQUFFLENBQUM7Z0JBQ1IxQixLQUFLLEVBQUU7YUFDUjtTQUFDLEdBQUcsRUFBRSxDQVBKLENBUUo7S0FDRixDQUFDO0FBQ0osQ0FBQztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2NoYXJ0T3B0aW9uc0J1aWxkZXIuanM/YmVjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmb3JtYXRPSExDRGF0YSwgZm9ybWF0Vm9sdW1lRGF0YSwgY2FsY3VsYXRlWUF4aXNSYW5nZSB9IGZyb20gJy4vZGF0YVV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBCdWlsZCBjaGFydCBvcHRpb25zIG9iamVjdCBiYXNlZCBvbiBwcm92aWRlZCBkYXRhIGFuZCBzZXR0aW5nc1xyXG4gKi9cclxuY29uc3QgYnVpbGRDaGFydE9wdGlvbnMgPSAoZGF0YSwgeyBcclxuICB0aXRsZSA9ICdQcmljZSBDaGFydCcsIFxyXG4gIHByaWNlVG9CYXJSYXRpbyA9IDAuMDAzNjksIFxyXG4gIGlzUmF0aW9Mb2NrZWQgPSB0cnVlLFxyXG4gIG9uU2V0RXh0cmVtZXMgPSBudWxsLFxyXG4gIHVwZGF0ZU9ITENEaXNwbGF5ID0gbnVsbFxyXG59KSA9PiB7XHJcbiAgaWYgKCFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcclxuICBcclxuICAvLyBQcm9jZXNzIGRhdGFcclxuICBjb25zdCBvaGxjRGF0YSA9IGZvcm1hdE9ITENEYXRhKGRhdGEpO1xyXG4gIGNvbnN0IHZvbHVtZURhdGEgPSBmb3JtYXRWb2x1bWVEYXRhKGRhdGEpO1xyXG4gIFxyXG4gIC8vIENhbGN1bGF0ZSBheGlzIHJhbmdlc1xyXG4gIGNvbnN0IHlBeGlzQ29uZmlnID0gY2FsY3VsYXRlWUF4aXNSYW5nZShkYXRhLCBwcmljZVRvQmFyUmF0aW8pO1xyXG4gIFxyXG4gIC8vIERhdGUgcmFuZ2UgaW5mb1xyXG4gIGNvbnN0IHN0YXJ0RGF0ZSA9IG9obGNEYXRhWzBdWzBdO1xyXG4gIGNvbnN0IGVuZERhdGUgPSBvaGxjRGF0YVtvaGxjRGF0YS5sZW5ndGggLSAxXVswXTtcclxuICBjb25zdCB0aW1lUmFuZ2UgPSBlbmREYXRlIC0gc3RhcnREYXRlO1xyXG4gIFxyXG4gIC8vIENvcmUgY2hhcnQgb3B0aW9ucyBzdHJ1Y3R1cmVcclxuICByZXR1cm4ge1xyXG4gICAgY2hhcnQ6IHtcclxuICAgICAgaGVpZ2h0OiA2MDAsXHJcbiAgICAgIGFuaW1hdGlvbjogZmFsc2UsXHJcbiAgICAgIHBhbm5pbmc6IHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIHR5cGU6ICd4eSdcclxuICAgICAgfSxcclxuICAgICAgem9vbVR5cGU6IG51bGwsXHJcbiAgICAgIGV2ZW50czoge1xyXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIERFQlVHOiBDaGFydCBsb2FkIGV2ZW50IHRyaWdnZXJlZFwiKTtcclxuICAgICAgICAgIC8vIEVuc3VyZSB6b29taW5nIGFuZCByYXRpbyBsb2NraW5nIHdvcmtzIHdpdGggdGhlIGluaXRpYWwgdmlld1xyXG4gICAgICAgICAgaWYgKGlzUmF0aW9Mb2NrZWQgJiYgb25TZXRFeHRyZW1lcykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gdGhpcy54QXhpc1swXTtcclxuICAgICAgICAgICAgICBjb25zdCBleHRyZW1lcyA9IHtcclxuICAgICAgICAgICAgICAgIG1pbjogeEF4aXMubWluLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB4QXhpcy5tYXhcclxuICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHByb3BlciBZLWF4aXMgcmFuZ2UgYmFzZWQgb24gdmlzaWJsZSBYIHJhbmdlXHJcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvblNldEV4dHJlbWVzKHhBeGlzLCBleHRyZW1lcyksIDEwMCk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFwcGx5aW5nIGluaXRpYWwgcmF0aW86XCIsIGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIvCflI0gREVCVUc6IENoYXJ0IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlZHJhdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAvLyBVcGRhdGUgT0hMQyBkaXNwbGF5IG9uIHJlZHJhdyBpZiBjYWxsYmFjayBwcm92aWRlZFxyXG4gICAgICAgICAgaWYgKHVwZGF0ZU9ITENEaXNwbGF5ICYmIHRoaXMuaG92ZXJQb2ludHMgJiYgdGhpcy5ob3ZlclBvaW50c1swXSkge1xyXG4gICAgICAgICAgICB1cGRhdGVPSExDRGlzcGxheSh0aGlzLmhvdmVyUG9pbnRzWzBdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vIFJhbmdlIHNlbGVjdG9yIG9wdGlvbnNcclxuICAgIHJhbmdlU2VsZWN0b3I6IHtcclxuICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgc2VsZWN0ZWQ6IDEsXHJcbiAgICAgIGJ1dHRvbnM6IFt7XHJcbiAgICAgICAgdHlwZTogJ21vbnRoJyxcclxuICAgICAgICBjb3VudDogMSxcclxuICAgICAgICB0ZXh0OiAnMW0nXHJcbiAgICAgIH0sIHtcclxuICAgICAgICB0eXBlOiAnbW9udGgnLFxyXG4gICAgICAgIGNvdW50OiAzLFxyXG4gICAgICAgIHRleHQ6ICczbSdcclxuICAgICAgfSwge1xyXG4gICAgICAgIHR5cGU6ICdtb250aCcsXHJcbiAgICAgICAgY291bnQ6IDYsXHJcbiAgICAgICAgdGV4dDogJzZtJ1xyXG4gICAgICB9LCB7XHJcbiAgICAgICAgdHlwZTogJ3l0ZCcsXHJcbiAgICAgICAgdGV4dDogJ1lURCdcclxuICAgICAgfSwge1xyXG4gICAgICAgIHR5cGU6ICd5ZWFyJyxcclxuICAgICAgICBjb3VudDogMSxcclxuICAgICAgICB0ZXh0OiAnMXknXHJcbiAgICAgIH0sIHtcclxuICAgICAgICB0eXBlOiAnYWxsJyxcclxuICAgICAgICB0ZXh0OiAnQWxsJ1xyXG4gICAgICB9XSxcclxuICAgICAgaW5wdXRFbmFibGVkOiB0cnVlXHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBOYXZpZ2F0b3IgYW5kIHNjcm9sbGJhclxyXG4gICAgbmF2aWdhdG9yOiB7IGVuYWJsZWQ6IHRydWUgfSxcclxuICAgIHNjcm9sbGJhcjogeyBlbmFibGVkOiB0cnVlIH0sXHJcbiAgICBcclxuICAgIC8vIENoYXJ0IHRpdGxlXHJcbiAgICB0aXRsZTogeyB0ZXh0OiB0aXRsZSB9LFxyXG4gICAgXHJcbiAgICAvLyBQbG90IHN0eWxpbmdcclxuICAgIHBsb3RPcHRpb25zOiB7XHJcbiAgICAgIGNhbmRsZXN0aWNrOiB7XHJcbiAgICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjb2xvcnMgdG8gbWFpbnRhaW4gb3JpZ2luYWwgYXBwZWFyYW5jZVxyXG4gICAgICAgIGNvbG9yOiAnIzJmN2VkOCcsICAgICAgLy8gRG93biBjYW5kbGVcclxuICAgICAgICB1cENvbG9yOiAnd2hpdGUnLCAgICAgIC8vIFVwIGNhbmRsZSBcclxuICAgICAgICBsaW5lQ29sb3I6ICcjMmY3ZWQ4JywgIC8vIERvd24gY2FuZGxlIGJvcmRlclxyXG4gICAgICAgIHVwTGluZUNvbG9yOiAnIzJmN2VkOCcsIC8vIFVwIGNhbmRsZSBib3JkZXJcclxuICAgICAgICBzdGF0ZXM6IHtcclxuICAgICAgICAgIGhvdmVyOiB7IGJyaWdodG5lc3M6IDAuMSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBFbnN1cmUgbm8gZ2FwcyBpbiBkYXRhXHJcbiAgICAgICAgZ2FwU2l6ZTogMCxcclxuICAgICAgICBkYXRhR3JvdXBpbmc6IHtcclxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlICAvLyBEaXNhYmxlIGRhdGEgZ3JvdXBpbmcgZm9yIGNvbnNpc3RlbnQgZGlzcGxheVxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgc2VyaWVzOiB7XHJcbiAgICAgICAgcG9pbnRQYWRkaW5nOiAwLjEsXHJcbiAgICAgICAgZ3JvdXBQYWRkaW5nOiAwLjEsXHJcbiAgICAgICAgYm9yZGVyV2lkdGg6IDEsXHJcbiAgICAgICAgZGF0YUdyb3VwaW5nOiB7XHJcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgLy8gVG9vbHRpcCBjb25maWd1cmF0aW9uXHJcbiAgICB0b29sdGlwOiB7XHJcbiAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgIGZvbGxvd1BvaW50ZXI6IHRydWUsXHJcbiAgICAgIGZvbGxvd1RvdWNoTW92ZTogdHJ1ZSxcclxuICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMucG9pbnRzIHx8ICF0aGlzLnBvaW50c1swXSB8fCAhdGhpcy5wb2ludHNbMF0ucG9pbnQpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIE9ITEMgZGlzcGxheSBpZiBjYWxsYmFjayBwcm92aWRlZFxyXG4gICAgICAgIGlmICh1cGRhdGVPSExDRGlzcGxheSkge1xyXG4gICAgICAgICAgdXBkYXRlT0hMQ0Rpc3BsYXkodGhpcy5wb2ludHNbMF0ucG9pbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgdG8gcHJldmVudCBzaG93aW5nIHRoZSB0b29sdGlwXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgXHJcbiAgICAvLyBYLWF4aXMgY29uZmlndXJhdGlvblxyXG4gICAgeEF4aXM6IHtcclxuICAgICAgb3JkaW5hbDogZmFsc2UsICAgICAgLy8gSW1wb3J0YW50IC0gZGlzYWJsZSBvcmRpbmFsIGF4aXMgdG8gcHJlc2VydmUgdGltZSBzY2FsZVxyXG4gICAgICBtaW5SYW5nZTogMjQgKiAzNjAwICogMTAwMCxcclxuICAgICAgb3ZlcnNjcm9sbDogMC41LFxyXG4gICAgICBldmVudHM6IHtcclxuICAgICAgICBhZnRlclNldEV4dHJlbWVzOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlgtYXhpcyBleHRyZW1lcyBjaGFuZ2VkOlwiLCBlLm1pbiwgZS5tYXgpO1xyXG4gICAgICAgICAgaWYgKCFpc1JhdGlvTG9ja2VkIHx8ICFvblNldEV4dHJlbWVzKSByZXR1cm47XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEFwcGx5IHJhdGlvIGxvY2sgd2hlbiBYLWF4aXMgY2hhbmdlc1xyXG4gICAgICAgICAgb25TZXRFeHRyZW1lcyh0aGlzLCBlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEV4dHJlbWVzOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAvLyBJZiByYXRpbyBsb2NrZWQsIHdlIG5lZWQgdG8gYWxzbyBsaXN0ZW4gZm9yIHNldEV4dHJlbWVzIChjYWxsZWQgYmVmb3JlIGFmdGVyU2V0RXh0cmVtZXMpXHJcbiAgICAgICAgICBpZiAoaXNSYXRpb0xvY2tlZCAmJiBlICYmIGUudHJpZ2dlciAmJiBlLnRyaWdnZXIgIT09ICdzeW5jRXh0cmVtZXMnKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiWC1heGlzIHNldEV4dHJlbWVzIGNhbGxlZDpcIiwgZS50cmlnZ2VyKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIC8vIFktYXhpcyBjb25maWd1cmF0aW9uXHJcbiAgICB5QXhpczogW3tcclxuICAgICAgLy8gUHJpY2UgYXhpc1xyXG4gICAgICBtaW46IHlBeGlzQ29uZmlnLm1pbixcclxuICAgICAgbWF4OiB5QXhpc0NvbmZpZy5tYXgsXHJcbiAgICAgIHN0YXJ0T25UaWNrOiBmYWxzZSxcclxuICAgICAgZW5kT25UaWNrOiBmYWxzZSxcclxuICAgICAgbWluUGFkZGluZzogMC4xLFxyXG4gICAgICBtYXhQYWRkaW5nOiAwLjEsXHJcbiAgICAgIGxhYmVsczogeyBhbGlnbjogJ3JpZ2h0JywgeDogLTMgfSxcclxuICAgICAgdGl0bGU6IHsgdGV4dDogJ1ByaWNlJyB9LFxyXG4gICAgICBoZWlnaHQ6ICc2MCUnLFxyXG4gICAgICBsaW5lV2lkdGg6IDIsXHJcbiAgICAgIHJlc2l6ZTogeyBlbmFibGVkOiB0cnVlIH0sXHJcbiAgICAgIGV2ZW50czoge1xyXG4gICAgICAgIGFmdGVyU2V0RXh0cmVtZXM6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiWS1heGlzIGV4dHJlbWVzIGNoYW5nZWQ6XCIsIGUubWluLCBlLm1heCk7XHJcbiAgICAgICAgICBpZiAoIWlzUmF0aW9Mb2NrZWQgfHwgIW9uU2V0RXh0cmVtZXMpIHJldHVybjtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gT25seSBhcHBseSByYXRpbyBsb2NrIHdoZW4gWS1heGlzIGNoYW5nZXMgZGlyZWN0bHkgKG5vdCBhcyByZXN1bHQgb2YgWCBjaGFuZ2UpXHJcbiAgICAgICAgICBpZiAoZS50cmlnZ2VyICYmIGUudHJpZ2dlciAhPT0gJ3N5bmNFeHRyZW1lcycpIHtcclxuICAgICAgICAgICAgb25TZXRFeHRyZW1lcyh0aGlzLCBlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sIHtcclxuICAgICAgLy8gVm9sdW1lIGF4aXNcclxuICAgICAgbGFiZWxzOiB7IGFsaWduOiAncmlnaHQnLCB4OiAtMyB9LFxyXG4gICAgICB0aXRsZTogeyB0ZXh0OiAnVm9sdW1lJyB9LFxyXG4gICAgICB0b3A6ICc2NSUnLFxyXG4gICAgICBoZWlnaHQ6ICczNSUnLFxyXG4gICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgIGxpbmVXaWR0aDogMlxyXG4gICAgfV0sXHJcbiAgICBcclxuICAgIC8vIFNlcmllcyBkYXRhXHJcbiAgICBzZXJpZXM6IFtcclxuICAgICAge1xyXG4gICAgICAgIHR5cGU6ICdjYW5kbGVzdGljaycsXHJcbiAgICAgICAgbmFtZTogJ1ByaWNlJyxcclxuICAgICAgICBpZDogJ3ByaWNlX2NoYXJ0JyxcclxuICAgICAgICBkYXRhOiBvaGxjRGF0YSxcclxuICAgICAgICBkYXRhR3JvdXBpbmc6IHsgZW5hYmxlZDogZmFsc2UgfSxcclxuICAgICAgICAvLyBDb2xvcnMgdG8gbWF0Y2ggb3JpZ2luYWwgYXBwZWFyYW5jZVxyXG4gICAgICAgIGNvbG9yOiAnIzJmN2VkOCcsICAgICAgLy8gRG93biBjYW5kbGVcclxuICAgICAgICB1cENvbG9yOiAnd2hpdGUnLCAgICAgIC8vIFVwIGNhbmRsZSBcclxuICAgICAgICBsaW5lQ29sb3I6ICcjMmY3ZWQ4JywgIC8vIERvd24gY2FuZGxlIGJvcmRlclxyXG4gICAgICAgIHVwTGluZUNvbG9yOiAnIzJmN2VkOCcgLy8gVXAgY2FuZGxlIGJvcmRlclxyXG4gICAgICB9LFxyXG4gICAgICAvLyBBZGQgdm9sdW1lIHNlcmllcyBpZiBhdmFpbGFibGVcclxuICAgICAgLi4uKHZvbHVtZURhdGEubGVuZ3RoID4gMCA/IFt7XHJcbiAgICAgICAgdHlwZTogJ2NvbHVtbicsXHJcbiAgICAgICAgbmFtZTogJ1ZvbHVtZScsXHJcbiAgICAgICAgaWQ6ICd2b2x1bWVfY2hhcnQnLFxyXG4gICAgICAgIGRhdGE6IHZvbHVtZURhdGEsXHJcbiAgICAgICAgeUF4aXM6IDEsXHJcbiAgICAgICAgY29sb3I6ICdyZ2JhKDEwMCwgMTAwLCAyNTUsIDAuNSknXHJcbiAgICAgIH1dIDogW10pXHJcbiAgICBdXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCB7IGJ1aWxkQ2hhcnRPcHRpb25zIH07ICJdLCJuYW1lcyI6WyJmb3JtYXRPSExDRGF0YSIsImZvcm1hdFZvbHVtZURhdGEiLCJjYWxjdWxhdGVZQXhpc1JhbmdlIiwiYnVpbGRDaGFydE9wdGlvbnMiLCJkYXRhIiwidGl0bGUiLCJwcmljZVRvQmFyUmF0aW8iLCJpc1JhdGlvTG9ja2VkIiwib25TZXRFeHRyZW1lcyIsInVwZGF0ZU9ITENEaXNwbGF5IiwibGVuZ3RoIiwib2hsY0RhdGEiLCJ2b2x1bWVEYXRhIiwieUF4aXNDb25maWciLCJzdGFydERhdGUiLCJlbmREYXRlIiwidGltZVJhbmdlIiwiY2hhcnQiLCJoZWlnaHQiLCJhbmltYXRpb24iLCJwYW5uaW5nIiwiZW5hYmxlZCIsInR5cGUiLCJ6b29tVHlwZSIsImV2ZW50cyIsImxvYWQiLCJjb25zb2xlIiwibG9nIiwieEF4aXMiLCJleHRyZW1lcyIsIm1pbiIsIm1heCIsInNldFRpbWVvdXQiLCJlcnJvciIsInJlZHJhdyIsImhvdmVyUG9pbnRzIiwicmFuZ2VTZWxlY3RvciIsInNlbGVjdGVkIiwiYnV0dG9ucyIsImNvdW50IiwidGV4dCIsImlucHV0RW5hYmxlZCIsIm5hdmlnYXRvciIsInNjcm9sbGJhciIsInBsb3RPcHRpb25zIiwiY2FuZGxlc3RpY2siLCJjb2xvciIsInVwQ29sb3IiLCJsaW5lQ29sb3IiLCJ1cExpbmVDb2xvciIsInN0YXRlcyIsImhvdmVyIiwiYnJpZ2h0bmVzcyIsImdhcFNpemUiLCJkYXRhR3JvdXBpbmciLCJzZXJpZXMiLCJwb2ludFBhZGRpbmciLCJncm91cFBhZGRpbmciLCJib3JkZXJXaWR0aCIsInRvb2x0aXAiLCJmb2xsb3dQb2ludGVyIiwiZm9sbG93VG91Y2hNb3ZlIiwiZm9ybWF0dGVyIiwicG9pbnRzIiwicG9pbnQiLCJvcmRpbmFsIiwibWluUmFuZ2UiLCJvdmVyc2Nyb2xsIiwiYWZ0ZXJTZXRFeHRyZW1lcyIsImUiLCJzZXRFeHRyZW1lcyIsInRyaWdnZXIiLCJ5QXhpcyIsInN0YXJ0T25UaWNrIiwiZW5kT25UaWNrIiwibWluUGFkZGluZyIsIm1heFBhZGRpbmciLCJsYWJlbHMiLCJhbGlnbiIsIngiLCJsaW5lV2lkdGgiLCJyZXNpemUiLCJ0b3AiLCJvZmZzZXQiLCJuYW1lIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/chartOptionsBuilder.js\n"));

/***/ })

});