"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/highstock-tradingview",{

/***/ "./utils/indicators.js":
/*!*****************************!*\
  !*** ./utils/indicators.js ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"calculateAngleBetweenPoints\": function() { return /* binding */ calculateAngleBetweenPoints; },\n/* harmony export */   \"getPivotPoints\": function() { return /* binding */ getPivotPoints; },\n/* harmony export */   \"registerCustomIndicators\": function() { return /* binding */ registerCustomIndicators; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/src/_to_consumable_array.mjs */ \"./node_modules/@swc/helpers/src/_to_consumable_array.mjs\");\n/**\n * Custom technical indicators for Highcharts\n * \n * This module contains:\n * - An angle calculator that respects the price-to-bar ratio\n * - Pivot point detection for identifying market tops and bottoms\n */ /**\n * Calculate the angle between two points, accounting for price-to-bar ratio\n * @param {Object} p1 - Starting point {x, y}\n * @param {Object} p2 - Ending point {x, y}\n * @param {Number} priceToBarRatio - The ratio of price units to bar units\n * @returns {Number} - Angle in degrees\n */ \nvar calculateAngleBetweenPoints = function(p1, p2) {\n    var priceToBarRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n    // Calculate the adjusted height based on the ratio\n    var dx = p2.x - p1.x;\n    var dy = (p2.y - p1.y) * priceToBarRatio;\n    // Calculate angle in radians and convert to degrees\n    var angleRad = Math.atan2(dy, dx);\n    var angleDeg = angleRad * (180 / Math.PI);\n    return angleDeg;\n};\n/**\n * Detect pivot points (highs and lows) in price data according to classical technical analysis\n * @param {Array} xData - Array of x values (timestamps or indices)\n * @param {Array} yData - Array of y values (prices)\n * @param {Object} params - Parameters { lookback }\n * @returns {Object} - Arrays of pivot high and low points\n */ var getPivotPoints = function(xData, yData) {\n    var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var _Math, _Math1;\n    var lookback = params.lookback || 5;\n    // Need at least 2*lookback+1 points to detect pivots\n    if (yData.length < 2 * lookback + 1) {\n        console.warn(\"Not enough data points (\".concat(yData.length, \") to detect pivots (need \").concat(2 * lookback + 1, \")\"));\n        return {\n            highs: [],\n            lows: []\n        };\n    }\n    var pivotHighs = [];\n    var pivotLows = [];\n    // Debug data range to ensure values make sense\n    var minPrice = (_Math = Math).min.apply(_Math, (0,_swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(yData));\n    var maxPrice = (_Math1 = Math).max.apply(_Math1, (0,_swc_helpers_src_to_consumable_array_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(yData));\n    console.log(\"Data range: min=\".concat(minPrice.toFixed(2), \", max=\").concat(maxPrice.toFixed(2), \", points=\").concat(yData.length));\n    // Iterate through the data, skipping the first and last 'lookback' points\n    for(var i = lookback; i < yData.length - lookback; i++){\n        // Get high and low for the current bar - for OHLC data\n        // If using close prices only, both will be the same value\n        var currentHigh = Array.isArray(yData[i]) ? yData[i][1] : yData[i]; // High\n        var currentLow = Array.isArray(yData[i]) ? yData[i][2] : yData[i]; // Low\n        // Check for pivot high - must be higher than ALL bars in the window\n        var isPivotHigh = true;\n        for(var j = i - lookback; j <= i + lookback; j++){\n            // Skip the current bar\n            if (j === i) continue;\n            // Get high of comparison bar\n            var compareHigh = Array.isArray(yData[j]) ? yData[j][1] : yData[j];\n            // If ANY bar in window has a higher high, this is not a pivot high\n            if (compareHigh >= currentHigh) {\n                isPivotHigh = false;\n                break;\n            }\n        }\n        // Check for pivot low - must be lower than ALL bars in the window\n        var isPivotLow = true;\n        for(var j1 = i - lookback; j1 <= i + lookback; j1++){\n            // Skip the current bar\n            if (j1 === i) continue;\n            // Get low of comparison bar\n            var compareLow = Array.isArray(yData[j1]) ? yData[j1][2] : yData[j1];\n            // If ANY bar in window has a lower low, this is not a pivot low\n            if (compareLow <= currentLow) {\n                isPivotLow = false;\n                break;\n            }\n        }\n        // Save pivot points with their coordinates\n        if (isPivotHigh) {\n            pivotHighs.push({\n                x: xData[i],\n                y: currentHigh,\n                index: i\n            });\n        }\n        if (isPivotLow) {\n            pivotLows.push({\n                x: xData[i],\n                y: currentLow,\n                index: i\n            });\n        }\n    }\n    console.log(\"Found \".concat(pivotHighs.length, \" highs and \").concat(pivotLows.length, \" lows in \").concat(yData.length, \" data points\"));\n    return {\n        highs: pivotHighs,\n        lows: pivotLows\n    };\n};\n/**\n * Register custom indicators with Highcharts\n * @param {Object} Highcharts - The Highcharts instance\n */ var registerCustomIndicators = function(Highcharts) {\n    var tryAlternativePivotMethod = // Fallback method that uses a different approach\n    function tryAlternativePivotMethod(chart, lookback) {\n        console.log(\"Trying alternative pivot detection method...\");\n        try {\n            // Get data from chart's rendered points\n            var points = [];\n            var mainSeries = null;\n            // Find the main price series\n            for(var i = 0; i < chart.series.length; i++){\n                var series = chart.series[i];\n                if (series.type === \"candlestick\" || series.type === \"ohlc\") {\n                    mainSeries = series;\n                    break;\n                }\n            }\n            if (!mainSeries || !mainSeries.points || mainSeries.points.length === 0) {\n                console.error(\"Could not find rendered points in any suitable series\");\n                return {\n                    highs: [],\n                    lows: []\n                };\n            }\n            // Extract data from rendered points\n            var xData = [];\n            var yData = [];\n            mainSeries.points.forEach(function(point) {\n                if (point && point.x && (point.close !== undefined || point.y !== undefined)) {\n                    xData.push(point.x);\n                    yData.push(point.close !== undefined ? point.close : point.y);\n                }\n            });\n            if (xData.length === 0) {\n                console.error(\"No usable data points found in rendered series\");\n                return {\n                    highs: [],\n                    lows: []\n                };\n            }\n            console.log(\"Processing \".concat(xData.length, \" data points from rendered series\"));\n            // Find pivot points \n            var ref = getPivotPoints(xData, yData, {\n                lookback: lookback\n            }), highs = ref.highs, lows = ref.lows;\n            console.log(\"Found \".concat(highs.length, \" highs and \").concat(lows.length, \" lows from rendered data\"));\n            // Remove any existing pivot series\n            chart.series.forEach(function(series) {\n                if (series.options.id === \"pivot-highs\" || series.options.id === \"pivot-lows\") {\n                    series.remove(false);\n                }\n            });\n            // Add pivot high markers\n            if (highs.length > 0) {\n                chart.addSeries({\n                    type: \"scatter\",\n                    name: \"Pivot Highs\",\n                    id: \"pivot-highs\",\n                    color: \"#21b838\",\n                    marker: {\n                        symbol: \"triangle\",\n                        radius: 8,\n                        fillColor: \"rgba(33, 184, 56, 0.9)\",\n                        lineColor: \"#ffffff\",\n                        lineWidth: 2\n                    },\n                    data: highs.map(function(point) {\n                        return [\n                            point.x,\n                            point.y\n                        ];\n                    }),\n                    showInLegend: false,\n                    tooltip: {\n                        pointFormat: '<span style=\"color:#21b838\">‚óè</span> Pivot High: <b>{point.y}</b><br/>'\n                    },\n                    zIndex: 10\n                }, false);\n            }\n            // Add pivot low markers\n            if (lows.length > 0) {\n                chart.addSeries({\n                    type: \"scatter\",\n                    name: \"Pivot Lows\",\n                    id: \"pivot-lows\",\n                    color: \"#d91e1e\",\n                    marker: {\n                        symbol: \"triangle-down\",\n                        radius: 8,\n                        fillColor: \"rgba(217, 30, 30, 0.9)\",\n                        lineColor: \"#ffffff\",\n                        lineWidth: 2\n                    },\n                    data: lows.map(function(point) {\n                        return [\n                            point.x,\n                            point.y\n                        ];\n                    }),\n                    showInLegend: false,\n                    tooltip: {\n                        pointFormat: '<span style=\"color:#d91e1e\">‚óè</span> Pivot Low: <b>{point.y}</b><br/>'\n                    },\n                    zIndex: 10\n                }, false);\n            }\n            // Redraw the chart\n            chart.redraw();\n            return {\n                highs: highs,\n                lows: lows\n            };\n        } catch (error) {\n            console.error(\"Error in alternative pivot method:\", error);\n            return {\n                highs: [],\n                lows: []\n            };\n        }\n    };\n    if (!Highcharts) {\n        console.error(\"Highcharts instance is required to register custom indicators\");\n        return;\n    }\n    // Add direct data approach for pivot points\n    Highcharts.createPivotPoints = function registerCustomIndicators(chart, seriesId) {\n        var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        // Safety check - make sure we have access to the chart\n        if (!chart) {\n            console.error(\"Invalid chart instance\");\n            return {\n                highs: [],\n                lows: []\n            };\n        }\n        var lookback = params.lookback || 5;\n        console.log(\"Creating pivot points with direct data approach, lookback=\".concat(lookback));\n        try {\n            // Get source data directly from the userOptions\n            var sourceData = chart.userOptions.series && chart.userOptions.series[0] && chart.userOptions.series[0].data;\n            if (!sourceData || !Array.isArray(sourceData) || sourceData.length === 0) {\n                console.error(\"No source data available in chart options\");\n                return {\n                    highs: [],\n                    lows: []\n                };\n            }\n            console.log(\"Processing \".concat(sourceData.length, \" data points from source data\"));\n            // Create separate arrays for timestamp, highs, and lows\n            var xData = [];\n            var highData = [];\n            var lowData = [];\n            // Extract high and low values properly from OHLC format\n            sourceData.forEach(function(point) {\n                if (Array.isArray(point) && point.length >= 4) {\n                    // Standard OHLC format [timestamp, open, high, low, close]\n                    xData.push(point[0]); // Timestamp\n                    highData.push(point[2]); // High\n                    lowData.push(point[3]); // Low\n                } else if (typeof point === \"object\" && point.x != null) {\n                    // Object format {x, open, high, low, close}\n                    xData.push(point.x);\n                    highData.push(point.high != null ? point.high : point.y);\n                    lowData.push(point.low != null ? point.low : point.y);\n                } else {\n                    // Simple price format\n                    xData.push(point[0]);\n                    highData.push(point[1]);\n                    lowData.push(point[1]);\n                }\n            });\n            // Find pivot highs using high values\n            var pivotHighs = [];\n            for(var i = lookback; i < highData.length - lookback; i++){\n                var isPivotHigh = true;\n                var currentHigh = highData[i];\n                for(var j = i - lookback; j <= i + lookback; j++){\n                    if (j === i) continue; // Skip the current bar\n                    if (highData[j] >= currentHigh) {\n                        isPivotHigh = false;\n                        break;\n                    }\n                }\n                if (isPivotHigh) {\n                    pivotHighs.push({\n                        x: xData[i],\n                        y: currentHigh,\n                        index: i\n                    });\n                }\n            }\n            // Find pivot lows using low values\n            var pivotLows = [];\n            for(var i1 = lookback; i1 < lowData.length - lookback; i1++){\n                var isPivotLow = true;\n                var currentLow = lowData[i1];\n                for(var j1 = i1 - lookback; j1 <= i1 + lookback; j1++){\n                    if (j1 === i1) continue; // Skip the current bar\n                    if (lowData[j1] <= currentLow) {\n                        isPivotLow = false;\n                        break;\n                    }\n                }\n                if (isPivotLow) {\n                    pivotLows.push({\n                        x: xData[i1],\n                        y: currentLow,\n                        index: i1\n                    });\n                }\n            }\n            console.log(\"Found \".concat(pivotHighs.length, \" highs and \").concat(pivotLows.length, \" lows using true OHLC data\"));\n            // Remove any existing pivot series\n            chart.series.forEach(function(series) {\n                if (series.options.id === \"pivot-highs\" || series.options.id === \"pivot-lows\") {\n                    series.remove(false);\n                }\n            });\n            // Add pivot high markers\n            if (pivotHighs.length > 0) {\n                chart.addSeries({\n                    type: \"scatter\",\n                    name: \"Pivot Highs\",\n                    id: \"pivot-highs\",\n                    color: \"#21b838\",\n                    marker: {\n                        symbol: \"triangle\",\n                        radius: 8,\n                        fillColor: \"rgba(33, 184, 56, 0.9)\",\n                        lineColor: \"#ffffff\",\n                        lineWidth: 2\n                    },\n                    data: pivotHighs.map(function(point) {\n                        return [\n                            point.x,\n                            point.y\n                        ];\n                    }),\n                    showInLegend: false,\n                    tooltip: {\n                        pointFormat: '<span style=\"color:#21b838\">‚óè</span> Pivot High: <b>{point.y}</b><br/>'\n                    },\n                    zIndex: 10\n                }, false);\n                console.log(\"Added pivot highs:\", pivotHighs.map(function(h) {\n                    return h.y.toFixed(2);\n                }).join(\", \"));\n            }\n            // Add pivot low markers\n            if (pivotLows.length > 0) {\n                chart.addSeries({\n                    type: \"scatter\",\n                    name: \"Pivot Lows\",\n                    id: \"pivot-lows\",\n                    color: \"#d91e1e\",\n                    marker: {\n                        symbol: \"triangle-down\",\n                        radius: 8,\n                        fillColor: \"rgba(217, 30, 30, 0.9)\",\n                        lineColor: \"#ffffff\",\n                        lineWidth: 2\n                    },\n                    data: pivotLows.map(function(point) {\n                        return [\n                            point.x,\n                            point.y\n                        ];\n                    }),\n                    showInLegend: false,\n                    tooltip: {\n                        pointFormat: '<span style=\"color:#d91e1e\">‚óè</span> Pivot Low: <b>{point.y}</b><br/>'\n                    },\n                    zIndex: 10\n                }, false);\n                console.log(\"Added pivot lows:\", pivotLows.map(function(l) {\n                    return l.y.toFixed(2);\n                }).join(\", \"));\n            }\n            // Redraw the chart\n            chart.redraw();\n            return {\n                highs: pivotHighs,\n                lows: pivotLows\n            };\n        } catch (error) {\n            console.error(\"Error creating pivot points with direct data approach:\", error);\n            // Fallback to another method if the direct approach fails\n            return tryAlternativePivotMethod(chart, lookback);\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM7d0JBQ1RDLFNBQVMsRUFBRSx3QkFBd0I7d0JBQ25DQyxTQUFTLEVBQUUsU0FBUzt3QkFDcEJDLFNBQVMsRUFBRSxDQUFDO3FCQUNiO29CQUNEQyxJQUFJLEVBQUU1QyxTQUFTLENBQUM2QyxHQUFHLENBQUNoQixTQUFBQSxLQUFLOytCQUFJOzRCQUFDQSxLQUFLLENBQUNoRCxDQUFDOzRCQUFFZ0QsS0FBSyxDQUFDOUMsQ0FBQzt5QkFBQztxQkFBQSxDQUFDO29CQUNoRCtELFlBQVksRUFBRSxLQUFLO29CQUNuQkMsT0FBTyxFQUFFO3dCQUNQQyxXQUFXLEVBQUUsdUVBQXVFO3FCQUNyRjtvQkFDREMsTUFBTSxFQUFFLEVBQUU7aUJBQ1gsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFFVnRELE9BQU8sQ0FBQ1UsR0FBRyxDQUFDLG1CQUFtQixFQUFFTCxTQUFTLENBQUM2QyxHQUFHLENBQUNnQixTQUFBQSxDQUFDOzJCQUFJQSxDQUFDLENBQUM5RSxDQUFDLENBQUN1QixPQUFPLENBQUMsQ0FBQyxDQUFDO2lCQUFBLENBQUMsQ0FBQ3NELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2xGLENBQUM7WUFFRCxtQkFBbUI7WUFDbkJ0QyxLQUFLLENBQUM0QixNQUFNLEVBQUUsQ0FBQztZQUNmLE9BQU87Z0JBQUVyRCxLQUFLLEVBQUVFLFVBQVU7Z0JBQUVELElBQUksRUFBRUUsU0FBUzthQUFFLENBQUM7UUFFaEQsRUFBRSxPQUFPMkIsS0FBSyxFQUFFO1lBQ2RoQyxPQUFPLENBQUNnQyxLQUFLLENBQUMsd0RBQXdELEVBQUVBLEtBQUssQ0FBQyxDQUFDO1lBRS9FLDBEQUEwRDtZQUMxRCxPQUFPTix5QkFBeUIsQ0FBQ0MsS0FBSyxFQUFFN0IsUUFBUSxDQUFDLENBQUM7UUFDcEQsQ0FBQztJQUNILENBQUMsQ0FBQztBQTRHSixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvaW5kaWNhdG9ycy5qcz9hNTRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3VzdG9tIHRlY2huaWNhbCBpbmRpY2F0b3JzIGZvciBIaWdoY2hhcnRzXG4gKiBcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zOlxuICogLSBBbiBhbmdsZSBjYWxjdWxhdG9yIHRoYXQgcmVzcGVjdHMgdGhlIHByaWNlLXRvLWJhciByYXRpb1xuICogLSBQaXZvdCBwb2ludCBkZXRlY3Rpb24gZm9yIGlkZW50aWZ5aW5nIG1hcmtldCB0b3BzIGFuZCBib3R0b21zXG4gKi9cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIHBvaW50cywgYWNjb3VudGluZyBmb3IgcHJpY2UtdG8tYmFyIHJhdGlvXG4gKiBAcGFyYW0ge09iamVjdH0gcDEgLSBTdGFydGluZyBwb2ludCB7eCwgeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwMiAtIEVuZGluZyBwb2ludCB7eCwgeX1cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmljZVRvQmFyUmF0aW8gLSBUaGUgcmF0aW8gb2YgcHJpY2UgdW5pdHMgdG8gYmFyIHVuaXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfSAtIEFuZ2xlIGluIGRlZ3JlZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZUFuZ2xlQmV0d2VlblBvaW50cyA9IChwMSwgcDIsIHByaWNlVG9CYXJSYXRpbyA9IDEpID0+IHtcbiAgLy8gQ2FsY3VsYXRlIHRoZSBhZGp1c3RlZCBoZWlnaHQgYmFzZWQgb24gdGhlIHJhdGlvXG4gIGNvbnN0IGR4ID0gcDIueCAtIHAxLng7XG4gIGNvbnN0IGR5ID0gKHAyLnkgLSBwMS55KSAqIHByaWNlVG9CYXJSYXRpbztcbiAgXG4gIC8vIENhbGN1bGF0ZSBhbmdsZSBpbiByYWRpYW5zIGFuZCBjb252ZXJ0IHRvIGRlZ3JlZXNcbiAgY29uc3QgYW5nbGVSYWQgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gIGNvbnN0IGFuZ2xlRGVnID0gYW5nbGVSYWQgKiAoMTgwIC8gTWF0aC5QSSk7XG4gIFxuICByZXR1cm4gYW5nbGVEZWc7XG59O1xuXG4vKipcbiAqIERldGVjdCBwaXZvdCBwb2ludHMgKGhpZ2hzIGFuZCBsb3dzKSBpbiBwcmljZSBkYXRhIGFjY29yZGluZyB0byBjbGFzc2ljYWwgdGVjaG5pY2FsIGFuYWx5c2lzXG4gKiBAcGFyYW0ge0FycmF5fSB4RGF0YSAtIEFycmF5IG9mIHggdmFsdWVzICh0aW1lc3RhbXBzIG9yIGluZGljZXMpXG4gKiBAcGFyYW0ge0FycmF5fSB5RGF0YSAtIEFycmF5IG9mIHkgdmFsdWVzIChwcmljZXMpXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gUGFyYW1ldGVycyB7IGxvb2tiYWNrIH1cbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gQXJyYXlzIG9mIHBpdm90IGhpZ2ggYW5kIGxvdyBwb2ludHNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBpdm90UG9pbnRzID0gKHhEYXRhLCB5RGF0YSwgcGFyYW1zID0ge30pID0+IHtcbiAgY29uc3QgbG9va2JhY2sgPSBwYXJhbXMubG9va2JhY2sgfHwgNTtcbiAgXG4gIC8vIE5lZWQgYXQgbGVhc3QgMipsb29rYmFjaysxIHBvaW50cyB0byBkZXRlY3QgcGl2b3RzXG4gIGlmICh5RGF0YS5sZW5ndGggPCAyICogbG9va2JhY2sgKyAxKSB7XG4gICAgY29uc29sZS53YXJuKGBOb3QgZW5vdWdoIGRhdGEgcG9pbnRzICgke3lEYXRhLmxlbmd0aH0pIHRvIGRldGVjdCBwaXZvdHMgKG5lZWQgJHsyICogbG9va2JhY2sgKyAxfSlgKTtcbiAgICByZXR1cm4geyBoaWdoczogW10sIGxvd3M6IFtdIH07XG4gIH1cbiAgXG4gIGNvbnN0IHBpdm90SGlnaHMgPSBbXTtcbiAgY29uc3QgcGl2b3RMb3dzID0gW107XG4gIFxuICAvLyBEZWJ1ZyBkYXRhIHJhbmdlIHRvIGVuc3VyZSB2YWx1ZXMgbWFrZSBzZW5zZVxuICBjb25zdCBtaW5QcmljZSA9IE1hdGgubWluKC4uLnlEYXRhKTtcbiAgY29uc3QgbWF4UHJpY2UgPSBNYXRoLm1heCguLi55RGF0YSk7XG4gIGNvbnNvbGUubG9nKGBEYXRhIHJhbmdlOiBtaW49JHttaW5QcmljZS50b0ZpeGVkKDIpfSwgbWF4PSR7bWF4UHJpY2UudG9GaXhlZCgyKX0sIHBvaW50cz0ke3lEYXRhLmxlbmd0aH1gKTtcbiAgXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgZGF0YSwgc2tpcHBpbmcgdGhlIGZpcnN0IGFuZCBsYXN0ICdsb29rYmFjaycgcG9pbnRzXG4gIGZvciAobGV0IGkgPSBsb29rYmFjazsgaSA8IHlEYXRhLmxlbmd0aCAtIGxvb2tiYWNrOyBpKyspIHtcbiAgICAvLyBHZXQgaGlnaCBhbmQgbG93IGZvciB0aGUgY3VycmVudCBiYXIgLSBmb3IgT0hMQyBkYXRhXG4gICAgLy8gSWYgdXNpbmcgY2xvc2UgcHJpY2VzIG9ubHksIGJvdGggd2lsbCBiZSB0aGUgc2FtZSB2YWx1ZVxuICAgIGNvbnN0IGN1cnJlbnRIaWdoID0gQXJyYXkuaXNBcnJheSh5RGF0YVtpXSkgPyB5RGF0YVtpXVsxXSA6IHlEYXRhW2ldOyAvLyBIaWdoXG4gICAgY29uc3QgY3VycmVudExvdyA9IEFycmF5LmlzQXJyYXkoeURhdGFbaV0pID8geURhdGFbaV1bMl0gOiB5RGF0YVtpXTsgIC8vIExvd1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBwaXZvdCBoaWdoIC0gbXVzdCBiZSBoaWdoZXIgdGhhbiBBTEwgYmFycyBpbiB0aGUgd2luZG93XG4gICAgbGV0IGlzUGl2b3RIaWdoID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBqID0gaSAtIGxvb2tiYWNrOyBqIDw9IGkgKyBsb29rYmFjazsgaisrKSB7XG4gICAgICAvLyBTa2lwIHRoZSBjdXJyZW50IGJhclxuICAgICAgaWYgKGogPT09IGkpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICAvLyBHZXQgaGlnaCBvZiBjb21wYXJpc29uIGJhclxuICAgICAgY29uc3QgY29tcGFyZUhpZ2ggPSBBcnJheS5pc0FycmF5KHlEYXRhW2pdKSA/IHlEYXRhW2pdWzFdIDogeURhdGFbal07XG4gICAgICBcbiAgICAgIC8vIElmIEFOWSBiYXIgaW4gd2luZG93IGhhcyBhIGhpZ2hlciBoaWdoLCB0aGlzIGlzIG5vdCBhIHBpdm90IGhpZ2hcbiAgICAgIGlmIChjb21wYXJlSGlnaCA+PSBjdXJyZW50SGlnaCkge1xuICAgICAgICBpc1Bpdm90SGlnaCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIHBpdm90IGxvdyAtIG11c3QgYmUgbG93ZXIgdGhhbiBBTEwgYmFycyBpbiB0aGUgd2luZG93XG4gICAgbGV0IGlzUGl2b3RMb3cgPSB0cnVlO1xuICAgIGZvciAobGV0IGogPSBpIC0gbG9va2JhY2s7IGogPD0gaSArIGxvb2tiYWNrOyBqKyspIHtcbiAgICAgIC8vIFNraXAgdGhlIGN1cnJlbnQgYmFyXG4gICAgICBpZiAoaiA9PT0gaSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIEdldCBsb3cgb2YgY29tcGFyaXNvbiBiYXJcbiAgICAgIGNvbnN0IGNvbXBhcmVMb3cgPSBBcnJheS5pc0FycmF5KHlEYXRhW2pdKSA/IHlEYXRhW2pdWzJdIDogeURhdGFbal07XG4gICAgICBcbiAgICAgIC8vIElmIEFOWSBiYXIgaW4gd2luZG93IGhhcyBhIGxvd2VyIGxvdywgdGhpcyBpcyBub3QgYSBwaXZvdCBsb3dcbiAgICAgIGlmIChjb21wYXJlTG93IDw9IGN1cnJlbnRMb3cpIHtcbiAgICAgICAgaXNQaXZvdExvdyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2F2ZSBwaXZvdCBwb2ludHMgd2l0aCB0aGVpciBjb29yZGluYXRlc1xuICAgIGlmIChpc1Bpdm90SGlnaCkge1xuICAgICAgcGl2b3RIaWdocy5wdXNoKHsgeDogeERhdGFbaV0sIHk6IGN1cnJlbnRIaWdoLCBpbmRleDogaSB9KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGlzUGl2b3RMb3cpIHtcbiAgICAgIHBpdm90TG93cy5wdXNoKHsgeDogeERhdGFbaV0sIHk6IGN1cnJlbnRMb3csIGluZGV4OiBpIH0pO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc29sZS5sb2coYEZvdW5kICR7cGl2b3RIaWdocy5sZW5ndGh9IGhpZ2hzIGFuZCAke3Bpdm90TG93cy5sZW5ndGh9IGxvd3MgaW4gJHt5RGF0YS5sZW5ndGh9IGRhdGEgcG9pbnRzYCk7XG4gIFxuICByZXR1cm4geyBoaWdoczogcGl2b3RIaWdocywgbG93czogcGl2b3RMb3dzIH07XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGN1c3RvbSBpbmRpY2F0b3JzIHdpdGggSGlnaGNoYXJ0c1xuICogQHBhcmFtIHtPYmplY3R9IEhpZ2hjaGFydHMgLSBUaGUgSGlnaGNoYXJ0cyBpbnN0YW5jZVxuICovXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJDdXN0b21JbmRpY2F0b3JzID0gKEhpZ2hjaGFydHMpID0+IHtcbiAgaWYgKCFIaWdoY2hhcnRzKSB7XG4gICAgY29uc29sZS5lcnJvcignSGlnaGNoYXJ0cyBpbnN0YW5jZSBpcyByZXF1aXJlZCB0byByZWdpc3RlciBjdXN0b20gaW5kaWNhdG9ycycpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFkZCBkaXJlY3QgZGF0YSBhcHByb2FjaCBmb3IgcGl2b3QgcG9pbnRzXG4gIEhpZ2hjaGFydHMuY3JlYXRlUGl2b3RQb2ludHMgPSBmdW5jdGlvbihjaGFydCwgc2VyaWVzSWQsIHBhcmFtcyA9IHt9KSB7XG4gICAgLy8gU2FmZXR5IGNoZWNrIC0gbWFrZSBzdXJlIHdlIGhhdmUgYWNjZXNzIHRvIHRoZSBjaGFydFxuICAgIGlmICghY2hhcnQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgY2hhcnQgaW5zdGFuY2UnKTtcbiAgICAgIHJldHVybiB7IGhpZ2hzOiBbXSwgbG93czogW10gfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbG9va2JhY2sgPSBwYXJhbXMubG9va2JhY2sgfHwgNTtcbiAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgcGl2b3QgcG9pbnRzIHdpdGggZGlyZWN0IGRhdGEgYXBwcm9hY2gsIGxvb2tiYWNrPSR7bG9va2JhY2t9YCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBzb3VyY2UgZGF0YSBkaXJlY3RseSBmcm9tIHRoZSB1c2VyT3B0aW9uc1xuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IGNoYXJ0LnVzZXJPcHRpb25zLnNlcmllcyAmJiBjaGFydC51c2VyT3B0aW9ucy5zZXJpZXNbMF0gJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnQudXNlck9wdGlvbnMuc2VyaWVzWzBdLmRhdGE7XG4gICAgICBcbiAgICAgIGlmICghc291cmNlRGF0YSB8fCAhQXJyYXkuaXNBcnJheShzb3VyY2VEYXRhKSB8fCBzb3VyY2VEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdObyBzb3VyY2UgZGF0YSBhdmFpbGFibGUgaW4gY2hhcnQgb3B0aW9ucycpO1xuICAgICAgICByZXR1cm4geyBoaWdoczogW10sIGxvd3M6IFtdIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7c291cmNlRGF0YS5sZW5ndGh9IGRhdGEgcG9pbnRzIGZyb20gc291cmNlIGRhdGFgKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHNlcGFyYXRlIGFycmF5cyBmb3IgdGltZXN0YW1wLCBoaWdocywgYW5kIGxvd3NcbiAgICAgIGNvbnN0IHhEYXRhID0gW107XG4gICAgICBjb25zdCBoaWdoRGF0YSA9IFtdO1xuICAgICAgY29uc3QgbG93RGF0YSA9IFtdO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IGhpZ2ggYW5kIGxvdyB2YWx1ZXMgcHJvcGVybHkgZnJvbSBPSExDIGZvcm1hdFxuICAgICAgc291cmNlRGF0YS5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocG9pbnQpICYmIHBvaW50Lmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgLy8gU3RhbmRhcmQgT0hMQyBmb3JtYXQgW3RpbWVzdGFtcCwgb3BlbiwgaGlnaCwgbG93LCBjbG9zZV1cbiAgICAgICAgICB4RGF0YS5wdXNoKHBvaW50WzBdKTsgIC8vIFRpbWVzdGFtcFxuICAgICAgICAgIGhpZ2hEYXRhLnB1c2gocG9pbnRbMl0pOyAvLyBIaWdoXG4gICAgICAgICAgbG93RGF0YS5wdXNoKHBvaW50WzNdKTsgIC8vIExvd1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwb2ludCA9PT0gJ29iamVjdCcgJiYgcG9pbnQueCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gT2JqZWN0IGZvcm1hdCB7eCwgb3BlbiwgaGlnaCwgbG93LCBjbG9zZX1cbiAgICAgICAgICB4RGF0YS5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIGhpZ2hEYXRhLnB1c2gocG9pbnQuaGlnaCAhPSBudWxsID8gcG9pbnQuaGlnaCA6IHBvaW50LnkpO1xuICAgICAgICAgIGxvd0RhdGEucHVzaChwb2ludC5sb3cgIT0gbnVsbCA/IHBvaW50LmxvdyA6IHBvaW50LnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbXBsZSBwcmljZSBmb3JtYXRcbiAgICAgICAgICB4RGF0YS5wdXNoKHBvaW50WzBdKTtcbiAgICAgICAgICBoaWdoRGF0YS5wdXNoKHBvaW50WzFdKTtcbiAgICAgICAgICBsb3dEYXRhLnB1c2gocG9pbnRbMV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRmluZCBwaXZvdCBoaWdocyB1c2luZyBoaWdoIHZhbHVlc1xuICAgICAgY29uc3QgcGl2b3RIaWdocyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IGxvb2tiYWNrOyBpIDwgaGlnaERhdGEubGVuZ3RoIC0gbG9va2JhY2s7IGkrKykge1xuICAgICAgICBsZXQgaXNQaXZvdEhpZ2ggPSB0cnVlO1xuICAgICAgICBjb25zdCBjdXJyZW50SGlnaCA9IGhpZ2hEYXRhW2ldO1xuICAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgLSBsb29rYmFjazsgaiA8PSBpICsgbG9va2JhY2s7IGorKykge1xuICAgICAgICAgIGlmIChqID09PSBpKSBjb250aW51ZTsgLy8gU2tpcCB0aGUgY3VycmVudCBiYXJcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoaGlnaERhdGFbal0gPj0gY3VycmVudEhpZ2gpIHtcbiAgICAgICAgICAgIGlzUGl2b3RIaWdoID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChpc1Bpdm90SGlnaCkge1xuICAgICAgICAgIHBpdm90SGlnaHMucHVzaCh7IHg6IHhEYXRhW2ldLCB5OiBjdXJyZW50SGlnaCwgaW5kZXg6IGkgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmluZCBwaXZvdCBsb3dzIHVzaW5nIGxvdyB2YWx1ZXNcbiAgICAgIGNvbnN0IHBpdm90TG93cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IGxvb2tiYWNrOyBpIDwgbG93RGF0YS5sZW5ndGggLSBsb29rYmFjazsgaSsrKSB7XG4gICAgICAgIGxldCBpc1Bpdm90TG93ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY3VycmVudExvdyA9IGxvd0RhdGFbaV07XG4gICAgICAgIFxuICAgICAgICBmb3IgKGxldCBqID0gaSAtIGxvb2tiYWNrOyBqIDw9IGkgKyBsb29rYmFjazsgaisrKSB7XG4gICAgICAgICAgaWYgKGogPT09IGkpIGNvbnRpbnVlOyAvLyBTa2lwIHRoZSBjdXJyZW50IGJhclxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChsb3dEYXRhW2pdIDw9IGN1cnJlbnRMb3cpIHtcbiAgICAgICAgICAgIGlzUGl2b3RMb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGlzUGl2b3RMb3cpIHtcbiAgICAgICAgICBwaXZvdExvd3MucHVzaCh7IHg6IHhEYXRhW2ldLCB5OiBjdXJyZW50TG93LCBpbmRleDogaSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtwaXZvdEhpZ2hzLmxlbmd0aH0gaGlnaHMgYW5kICR7cGl2b3RMb3dzLmxlbmd0aH0gbG93cyB1c2luZyB0cnVlIE9ITEMgZGF0YWApO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHBpdm90IHNlcmllc1xuICAgICAgY2hhcnQuc2VyaWVzLmZvckVhY2goc2VyaWVzID0+IHtcbiAgICAgICAgaWYgKHNlcmllcy5vcHRpb25zLmlkID09PSAncGl2b3QtaGlnaHMnIHx8IHNlcmllcy5vcHRpb25zLmlkID09PSAncGl2b3QtbG93cycpIHtcbiAgICAgICAgICBzZXJpZXMucmVtb3ZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBwaXZvdCBoaWdoIG1hcmtlcnNcbiAgICAgIGlmIChwaXZvdEhpZ2hzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hhcnQuYWRkU2VyaWVzKHtcbiAgICAgICAgICB0eXBlOiAnc2NhdHRlcicsXG4gICAgICAgICAgbmFtZTogJ1Bpdm90IEhpZ2hzJyxcbiAgICAgICAgICBpZDogJ3Bpdm90LWhpZ2hzJyxcbiAgICAgICAgICBjb2xvcjogJyMyMWI4MzgnLFxuICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgc3ltYm9sOiAndHJpYW5nbGUnLFxuICAgICAgICAgICAgcmFkaXVzOiA4LFxuICAgICAgICAgICAgZmlsbENvbG9yOiAncmdiYSgzMywgMTg0LCA1NiwgMC45KScsXG4gICAgICAgICAgICBsaW5lQ29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YTogcGl2b3RIaWdocy5tYXAocG9pbnQgPT4gW3BvaW50LngsIHBvaW50LnldKSxcbiAgICAgICAgICBzaG93SW5MZWdlbmQ6IGZhbHNlLFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHBvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjojMjFiODM4XCI+4pePPC9zcGFuPiBQaXZvdCBIaWdoOiA8Yj57cG9pbnQueX08L2I+PGJyLz4nXG4gICAgICAgICAgfSxcbiAgICAgICAgICB6SW5kZXg6IDEwXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWRkZWQgcGl2b3QgaGlnaHM6XCIsIHBpdm90SGlnaHMubWFwKGggPT4gaC55LnRvRml4ZWQoMikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBwaXZvdCBsb3cgbWFya2Vyc1xuICAgICAgaWYgKHBpdm90TG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNoYXJ0LmFkZFNlcmllcyh7XG4gICAgICAgICAgdHlwZTogJ3NjYXR0ZXInLFxuICAgICAgICAgIG5hbWU6ICdQaXZvdCBMb3dzJyxcbiAgICAgICAgICBpZDogJ3Bpdm90LWxvd3MnLFxuICAgICAgICAgIGNvbG9yOiAnI2Q5MWUxZScsXG4gICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICBzeW1ib2w6ICd0cmlhbmdsZS1kb3duJyxcbiAgICAgICAgICAgIHJhZGl1czogOCxcbiAgICAgICAgICAgIGZpbGxDb2xvcjogJ3JnYmEoMjE3LCAzMCwgMzAsIDAuOSknLFxuICAgICAgICAgICAgbGluZUNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRhdGE6IHBpdm90TG93cy5tYXAocG9pbnQgPT4gW3BvaW50LngsIHBvaW50LnldKSxcbiAgICAgICAgICBzaG93SW5MZWdlbmQ6IGZhbHNlLFxuICAgICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICAgIHBvaW50Rm9ybWF0OiAnPHNwYW4gc3R5bGU9XCJjb2xvcjojZDkxZTFlXCI+4pePPC9zcGFuPiBQaXZvdCBMb3c6IDxiPntwb2ludC55fTwvYj48YnIvPidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpJbmRleDogMTBcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coXCJBZGRlZCBwaXZvdCBsb3dzOlwiLCBwaXZvdExvd3MubWFwKGwgPT4gbC55LnRvRml4ZWQoMikpLmpvaW4oXCIsIFwiKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlZHJhdyB0aGUgY2hhcnRcbiAgICAgIGNoYXJ0LnJlZHJhdygpO1xuICAgICAgcmV0dXJuIHsgaGlnaHM6IHBpdm90SGlnaHMsIGxvd3M6IHBpdm90TG93cyB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBpdm90IHBvaW50cyB3aXRoIGRpcmVjdCBkYXRhIGFwcHJvYWNoOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8gYW5vdGhlciBtZXRob2QgaWYgdGhlIGRpcmVjdCBhcHByb2FjaCBmYWlsc1xuICAgICAgcmV0dXJuIHRyeUFsdGVybmF0aXZlUGl2b3RNZXRob2QoY2hhcnQsIGxvb2tiYWNrKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBGYWxsYmFjayBtZXRob2QgdGhhdCB1c2VzIGEgZGlmZmVyZW50IGFwcHJvYWNoXG4gIGZ1bmN0aW9uIHRyeUFsdGVybmF0aXZlUGl2b3RNZXRob2QoY2hhcnQsIGxvb2tiYWNrKSB7XG4gICAgY29uc29sZS5sb2coXCJUcnlpbmcgYWx0ZXJuYXRpdmUgcGl2b3QgZGV0ZWN0aW9uIG1ldGhvZC4uLlwiKTtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGRhdGEgZnJvbSBjaGFydCdzIHJlbmRlcmVkIHBvaW50c1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBsZXQgbWFpblNlcmllcyA9IG51bGw7XG4gICAgICBcbiAgICAgIC8vIEZpbmQgdGhlIG1haW4gcHJpY2Ugc2VyaWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJ0LnNlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzZXJpZXMgPSBjaGFydC5zZXJpZXNbaV07XG4gICAgICAgIGlmIChzZXJpZXMudHlwZSA9PT0gJ2NhbmRsZXN0aWNrJyB8fCBzZXJpZXMudHlwZSA9PT0gJ29obGMnKSB7XG4gICAgICAgICAgbWFpblNlcmllcyA9IHNlcmllcztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIW1haW5TZXJpZXMgfHwgIW1haW5TZXJpZXMucG9pbnRzIHx8IG1haW5TZXJpZXMucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IGZpbmQgcmVuZGVyZWQgcG9pbnRzIGluIGFueSBzdWl0YWJsZSBzZXJpZXNcIik7XG4gICAgICAgIHJldHVybiB7IGhpZ2hzOiBbXSwgbG93czogW10gfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCBkYXRhIGZyb20gcmVuZGVyZWQgcG9pbnRzXG4gICAgICBjb25zdCB4RGF0YSA9IFtdO1xuICAgICAgY29uc3QgeURhdGEgPSBbXTtcbiAgICAgIFxuICAgICAgbWFpblNlcmllcy5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgIGlmIChwb2ludCAmJiBwb2ludC54ICYmIChwb2ludC5jbG9zZSAhPT0gdW5kZWZpbmVkIHx8IHBvaW50LnkgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICB4RGF0YS5wdXNoKHBvaW50LngpO1xuICAgICAgICAgIHlEYXRhLnB1c2gocG9pbnQuY2xvc2UgIT09IHVuZGVmaW5lZCA/IHBvaW50LmNsb3NlIDogcG9pbnQueSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoeERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyB1c2FibGUgZGF0YSBwb2ludHMgZm91bmQgaW4gcmVuZGVyZWQgc2VyaWVzXCIpO1xuICAgICAgICByZXR1cm4geyBoaWdoczogW10sIGxvd3M6IFtdIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nICR7eERhdGEubGVuZ3RofSBkYXRhIHBvaW50cyBmcm9tIHJlbmRlcmVkIHNlcmllc2ApO1xuICAgICAgXG4gICAgICAvLyBGaW5kIHBpdm90IHBvaW50cyBcbiAgICAgIGNvbnN0IHsgaGlnaHMsIGxvd3MgfSA9IGdldFBpdm90UG9pbnRzKHhEYXRhLCB5RGF0YSwgeyBsb29rYmFjayB9KTtcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2hpZ2hzLmxlbmd0aH0gaGlnaHMgYW5kICR7bG93cy5sZW5ndGh9IGxvd3MgZnJvbSByZW5kZXJlZCBkYXRhYCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcGl2b3Qgc2VyaWVzXG4gICAgICBjaGFydC5zZXJpZXMuZm9yRWFjaChzZXJpZXMgPT4ge1xuICAgICAgICBpZiAoc2VyaWVzLm9wdGlvbnMuaWQgPT09ICdwaXZvdC1oaWdocycgfHwgc2VyaWVzLm9wdGlvbnMuaWQgPT09ICdwaXZvdC1sb3dzJykge1xuICAgICAgICAgIHNlcmllcy5yZW1vdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHBpdm90IGhpZ2ggbWFya2Vyc1xuICAgICAgaWYgKGhpZ2hzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hhcnQuYWRkU2VyaWVzKHtcbiAgICAgICAgICB0eXBlOiAnc2NhdHRlcicsXG4gICAgICAgICAgbmFtZTogJ1Bpdm90IEhpZ2hzJyxcbiAgICAgICAgICBpZDogJ3Bpdm90LWhpZ2hzJyxcbiAgICAgICAgICBjb2xvcjogJyMyMWI4MzgnLFxuICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgc3ltYm9sOiAndHJpYW5nbGUnLFxuICAgICAgICAgICAgcmFkaXVzOiA4LFxuICAgICAgICAgICAgZmlsbENvbG9yOiAncmdiYSgzMywgMTg0LCA1NiwgMC45KScsXG4gICAgICAgICAgICBsaW5lQ29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGF0YTogaGlnaHMubWFwKHBvaW50ID0+IFtwb2ludC54LCBwb2ludC55XSksXG4gICAgICAgICAgc2hvd0luTGVnZW5kOiBmYWxzZSxcbiAgICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgICBwb2ludEZvcm1hdDogJzxzcGFuIHN0eWxlPVwiY29sb3I6IzIxYjgzOFwiPuKXjzwvc3Bhbj4gUGl2b3QgSGlnaDogPGI+e3BvaW50Lnl9PC9iPjxici8+J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgekluZGV4OiAxMFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBwaXZvdCBsb3cgbWFya2Vyc1xuICAgICAgaWYgKGxvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGFydC5hZGRTZXJpZXMoe1xuICAgICAgICAgIHR5cGU6ICdzY2F0dGVyJyxcbiAgICAgICAgICBuYW1lOiAnUGl2b3QgTG93cycsXG4gICAgICAgICAgaWQ6ICdwaXZvdC1sb3dzJyxcbiAgICAgICAgICBjb2xvcjogJyNkOTFlMWUnLFxuICAgICAgICAgIG1hcmtlcjoge1xuICAgICAgICAgICAgc3ltYm9sOiAndHJpYW5nbGUtZG93bicsXG4gICAgICAgICAgICByYWRpdXM6IDgsXG4gICAgICAgICAgICBmaWxsQ29sb3I6ICdyZ2JhKDIxNywgMzAsIDMwLCAwLjkpJyxcbiAgICAgICAgICAgIGxpbmVDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkYXRhOiBsb3dzLm1hcChwb2ludCA9PiBbcG9pbnQueCwgcG9pbnQueV0pLFxuICAgICAgICAgIHNob3dJbkxlZ2VuZDogZmFsc2UsXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgcG9pbnRGb3JtYXQ6ICc8c3BhbiBzdHlsZT1cImNvbG9yOiNkOTFlMWVcIj7il488L3NwYW4+IFBpdm90IExvdzogPGI+e3BvaW50Lnl9PC9iPjxici8+J1xuICAgICAgICAgIH0sXG4gICAgICAgICAgekluZGV4OiAxMFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlZHJhdyB0aGUgY2hhcnRcbiAgICAgIGNoYXJ0LnJlZHJhdygpO1xuICAgICAgcmV0dXJuIHsgaGlnaHMsIGxvd3MgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBhbHRlcm5hdGl2ZSBwaXZvdCBtZXRob2Q6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgaGlnaHM6IFtdLCBsb3dzOiBbXSB9O1xuICAgIH1cbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJjYWxjdWxhdGVBbmdsZUJldHdlZW5Qb2ludHMiLCJwMSIsInAyIiwicHJpY2VUb0JhclJhdGlvIiwiZHgiLCJ4IiwiZHkiLCJ5IiwiYW5nbGVSYWQiLCJNYXRoIiwiYXRhbjIiLCJhbmdsZURlZyIsIlBJIiwiZ2V0UGl2b3RQb2ludHMiLCJ4RGF0YSIsInlEYXRhIiwicGFyYW1zIiwibG9va2JhY2siLCJsZW5ndGgiLCJjb25zb2xlIiwid2FybiIsImhpZ2hzIiwibG93cyIsInBpdm90SGlnaHMiLCJwaXZvdExvd3MiLCJtaW5QcmljZSIsIm1pbiIsIm1heFByaWNlIiwibWF4IiwibG9nIiwidG9GaXhlZCIsImkiLCJjdXJyZW50SGlnaCIsIkFycmF5IiwiaXNBcnJheSIsImN1cnJlbnRMb3ciLCJpc1Bpdm90SGlnaCIsImoiLCJjb21wYXJlSGlnaCIsImlzUGl2b3RMb3ciLCJjb21wYXJlTG93IiwicHVzaCIsImluZGV4IiwicmVnaXN0ZXJDdXN0b21JbmRpY2F0b3JzIiwiSGlnaGNoYXJ0cyIsInRyeUFsdGVybmF0aXZlUGl2b3RNZXRob2QiLCJjaGFydCIsInBvaW50cyIsIm1haW5TZXJpZXMiLCJzZXJpZXMiLCJ0eXBlIiwiZXJyb3IiLCJmb3JFYWNoIiwicG9pbnQiLCJjbG9zZSIsInVuZGVmaW5lZCIsIm9wdGlvbnMiLCJpZCIsInJlbW92ZSIsImFkZFNlcmllcyIsIm5hbWUiLCJjb2xvciIsIm1hcmtlciIsInN5bWJvbCIsInJhZGl1cyIsImZpbGxDb2xvciIsImxpbmVDb2xvciIsImxpbmVXaWR0aCIsImRhdGEiLCJtYXAiLCJzaG93SW5MZWdlbmQiLCJ0b29sdGlwIiwicG9pbnRGb3JtYXQiLCJ6SW5kZXgiLCJyZWRyYXciLCJjcmVhdGVQaXZvdFBvaW50cyIsInNlcmllc0lkIiwic291cmNlRGF0YSIsInVzZXJPcHRpb25zIiwiaGlnaERhdGEiLCJsb3dEYXRhIiwiaGlnaCIsImxvdyIsImgiLCJqb2luIiwibCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/indicators.js\n"));

/***/ })

});