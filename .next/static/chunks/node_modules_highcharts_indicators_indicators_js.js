/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_highcharts_indicators_indicators_js"],{

/***/ "./node_modules/highcharts/indicators/indicators.js":
/*!**********************************************************!*\
  !*** ./node_modules/highcharts/indicators/indicators.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!/**\n * Highstock JS v12.1.2 (2024-12-21)\n * @module highcharts/indicators/indicators\n * @requires highcharts\n * @requires highcharts/modules/stock\n *\n * Indicator series type for Highcharts Stock\n *\n * (c) 2010-2024 Pawel Fus, Sebastian Bochan\n *\n * License: www.highcharts.com/license\n */function(t,e){ true?module.exports=e(t._Highcharts,t._Highcharts.Chart,t._Highcharts.SeriesRegistry):0}(\"undefined\"==typeof window?this:window,(t,e,a)=>(()=>{\"use strict\";var i,s={960:t=>{t.exports=e},512:t=>{t.exports=a},944:e=>{e.exports=t}},n={};function r(t){var e=n[t];if(void 0!==e)return e.exports;var a=n[t]={exports:{}};return s[t](a,a.exports,r),a.exports}r.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return r.d(e,{a:e}),e},r.d=(t,e)=>{for(var a in e)r.o(e,a)&&!r.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:e[a]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var o={};r.d(o,{default:()=>N});var l=r(944),h=r.n(l),p=r(960),d=r.n(p),u=r(512),c=r.n(u);let{line:f}=c().seriesTypes,{addEvent:m,fireEvent:x,error:y,extend:g,isArray:D,merge:P,pick:C}=h(),v=(t,e)=>{let a=[],i=t.pointArrayMap,s=e&&t.dataTable.modified||t.dataTable;if(!i)return t.getColumn(\"y\",e);let n=i.map(a=>t.getColumn(a,e));for(let t=0;t<s.rowCount;t++){let e=i.map((e,a)=>n[a]?.[t]||0);a.push(e)}return a};class A extends f{destroy(){this.dataEventsToUnbind.forEach(function(t){t()}),super.destroy.apply(this,arguments)}getName(){let t=[],e=this.name;return e||((this.nameComponents||[]).forEach(function(e,a){t.push(this.options.params[e]+C(this.nameSuffixes[a],\"\"))},this),e=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?\" (\"+t.join(\", \")+\")\":\"\")),e}getValues(t,e){let a=e.period,i=t.xData||[],s=t.yData,n=s.length,r=[],o=[],l=[],h,p=-1,d=0,u,c=0;if(!(i.length<a)){for(D(s[0])&&(p=e.index?e.index:0);d<a-1;)c+=p<0?s[d]:s[d][p],d++;for(h=d;h<n;h++)c+=p<0?s[h]:s[h][p],u=[i[h],c/a],r.push(u),o.push(u[0]),l.push(u[1]),c-=p<0?s[h-d]:s[h-d][p];return{values:r,xData:o,yData:l}}}init(t,e){let a=this;super.init.call(a,t,e);let i=m(d(),\"afterLinkSeries\",function({isUpdating:e}){if(e)return;let i=!!a.dataEventsToUnbind.length;if(!a.linkedParent)return y(\"Series \"+a.options.linkedTo+\" not found! Check `linkedTo`.\",!1,t);if(!i&&(a.dataEventsToUnbind.push(m(a.linkedParent,\"updatedData\",function(){a.recalculateValues()})),a.calculateOn.xAxis&&a.dataEventsToUnbind.push(m(a.linkedParent.xAxis,a.calculateOn.xAxis,function(){a.recalculateValues()}))),\"init\"===a.calculateOn.chart)a.closestPointRange||a.recalculateValues();else if(!i){let t=m(a.chart,a.calculateOn.chart,function(){a.recalculateValues(),t()})}},{order:0});a.dataEventsToUnbind=[],a.eventsToUnbind.push(i)}recalculateValues(){let t=[],e=this.dataTable,a=this.points||[],i=this.dataTable.rowCount,s=!0,n,r,o,l,h=this.linkedParent.yData,p=this.linkedParent.processedYData;this.linkedParent.xData=this.linkedParent.getColumn(\"x\"),this.linkedParent.yData=v(this.linkedParent),this.linkedParent.processedYData=v(this.linkedParent,!0);let d=this.linkedParent.options&&this.linkedParent.dataTable.rowCount&&this.getValues(this.linkedParent,this.options.params)||{values:[],xData:[],yData:[]};delete this.linkedParent.xData,this.linkedParent.yData=h,this.linkedParent.processedYData=p;let u=this.pointArrayMap||[\"y\"],c={};if(d.yData.forEach(t=>{u.forEach((e,a)=>{let i=c[e]||[];i.push(D(t)?t[a]:t),c[e]||(c[e]=i)})}),i&&!this.hasGroupedData&&this.visible&&this.points){if(this.cropped){this.xAxis&&(o=this.xAxis.min,l=this.xAxis.max);let i=this.cropData(e,o,l),s=[\"x\",...this.pointArrayMap||[\"y\"]];for(let e=0;e<(i.modified?.rowCount||0);e++){let a=s.map(t=>this.getColumn(t)[e]||0);t.push(a)}let h=this.getColumn(\"x\");n=d.xData.indexOf(h[0]),r=d.xData.indexOf(h[h.length-1]),-1===n&&r===d.xData.length-2&&t[0][0]===a[0].x&&t.shift(),this.updateData(t)}else(this.updateAllPoints||d.xData.length!==i-1&&d.xData.length!==i+1)&&(s=!1,this.updateData(d.values))}s&&(e.setColumns({...c,x:d.xData}),this.options.data=d.values),this.calculateOn.xAxis&&this.getColumn(\"x\",!0).length&&(this.isDirty=!0,this.redraw()),this.isDirtyData=!!this.linkedSeries.length,x(this,\"updatedData\")}processData(){let t=this.options.compareToMain,e=this.linkedParent;super.processData.apply(this,arguments),this.dataModify&&e&&e.dataModify&&e.dataModify.compareValue&&t&&(this.dataModify.compareValue=e.dataModify.compareValue)}}A.defaultOptions=P(f.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),g(A.prototype,{calculateOn:{chart:\"init\"},hasDerivedData:!0,nameComponents:[\"period\"],nameSuffixes:[],useCommonDataGrouping:!0}),c().registerSeriesType(\"sma\",A);let{sma:k}=c().seriesTypes,{correctFloat:T,isArray:M,merge:O}=h();class b extends k{accumulatePeriodPoints(t,e,a){let i=0,s=0;for(;s<t;)i+=e<0?a[s]:a[s][e],s++;return i}calculateEma(t,e,a,i,s,n,r){let o=t[a-1],l=n<0?e[a-1]:e[a-1][n];return[o,void 0===s?r:T(l*i+s*(1-i))]}getValues(t,e){let a=e.period,i=t.xData,s=t.yData,n=s?s.length:0,r=2/(a+1),o=[],l=[],h=[],p,d,u,c=-1,f=0;if(!(n<a)){for(M(s[0])&&(c=e.index?e.index:0),f=this.accumulatePeriodPoints(a,c,s)/a,u=a;u<n+1;u++)d=this.calculateEma(i,s,u,r,p,c,f),o.push(d),l.push(d[0]),h.push(d[1]),p=d[1];return{values:o,xData:l,yData:h}}}}b.defaultOptions=O(k.defaultOptions,{params:{index:3,period:9}}),c().registerSeriesType(\"ema\",b);let{sma:{prototype:E}}=c().seriesTypes,{defined:w,error:S,merge:V}=h();!function(t){let e=[\"bottomLine\"],a=[\"top\",\"bottom\"],i=[\"top\"];function s(t){return\"plot\"+t.charAt(0).toUpperCase()+t.slice(1)}function n(t,e){let a=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&a.push(s(t))}),a}function r(){let t=this,e=t.pointValKey,a=t.linesApiNames,i=t.areaLinesNames,r=t.points,o=t.options,l=t.graph,h={options:{gapSize:o.gapSize}},p=[],d=n(t,e),u=r.length,c;if(d.forEach((t,e)=>{for(p[e]=[];u--;)c=r[u],p[e].push({x:c.x,plotX:c.plotX,plotY:c[t],isNull:!w(c[t])});u=r.length}),t.userOptions.fillColor&&i.length){let e=p[d.indexOf(s(i[0]))],a=1===i.length?r:p[d.indexOf(s(i[1]))],n=t.color;t.points=a,t.nextPoints=e,t.color=t.userOptions.fillColor,t.options=V(r,h),t.graph=t.area,t.fillGraph=!0,E.drawGraph.call(t),t.area=t.graph,delete t.nextPoints,delete t.fillGraph,t.color=n}a.forEach((e,a)=>{p[a]?(t.points=p[a],o[e]?t.options=V(o[e].styles,h):S('Error: \"There is no '+e+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names.\"'),t.graph=t[\"graph\"+e],E.drawGraph.call(t),t[\"graph\"+e]=t.graph):S('Error: \"'+e+\" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\\\"\")}),t.points=r,t.options=o,t.graph=l,E.drawGraph.call(t)}function o(t){let e,a=[],i=[];if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=E.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]=\"L\",a=E.getGraphPath.call(this,t),i=e.slice(0,a.length);for(let t=i.length-1;t>=0;t--)a.push(i[t])}}else a=E.getGraphPath.apply(this,arguments);return a}function l(t){let e=[];return(this.pointArrayMap||[]).forEach(a=>{e.push(t[a])}),e}function h(){let t=this.pointArrayMap,e=[],a;e=n(this),E.translate.apply(this,arguments),this.points.forEach(i=>{t.forEach((t,s)=>{a=i[t],this.dataModify&&(a=this.dataModify.modifyValue(a)),null!==a&&(i[e[s]]=this.yAxis.toPixels(a,!0))})})}t.compose=function(t){let s=t.prototype;return s.linesApiNames=s.linesApiNames||e.slice(),s.pointArrayMap=s.pointArrayMap||a.slice(),s.pointValKey=s.pointValKey||\"top\",s.areaLinesNames=s.areaLinesNames||i.slice(),s.drawGraph=r,s.getGraphPath=o,s.toYData=l,s.translate=h,t}}(i||(i={}));let G=i,H=h();H.MultipleLinesComposition=H.MultipleLinesComposition||G;let N=h();return o.default})());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy9pbmRpY2F0b3JzL2luZGljYXRvcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFpRCxrRkFBa0YsQ0FBK1csQ0FBQyx1REFBdUQsYUFBYSxTQUFTLFFBQVEsWUFBWSxTQUFTLFlBQVksU0FBUyxhQUFhLE1BQU0sY0FBYyxXQUFXLCtCQUErQixZQUFZLFlBQVkscUNBQXFDLFFBQVEsMENBQTBDLGNBQWMsSUFBSSxJQUFJLGFBQWEsK0RBQStELHVCQUF1QixFQUFFLHNEQUFzRCxTQUFTLE9BQU8sY0FBYyxFQUFFLDBEQUEwRCxJQUFJLE9BQU8sa0JBQWtCLGlFQUFpRSxlQUFlLGtFQUFrRSxnQ0FBZ0MsaUNBQWlDLFlBQVksYUFBYSxLQUFLLGlDQUFpQyxVQUFVLFVBQVUsa0JBQWtCLFVBQVUsNENBQTRDLElBQUksc0NBQXNDLFVBQVUscUJBQXFCLDJEQUEyRCwwREFBMEQsb0dBQW9HLGVBQWUsa0ZBQWtGLGtCQUFrQixtQ0FBbUMsTUFBTSx5QkFBeUIsUUFBUSxJQUFJLGlHQUFpRyxPQUFPLDJCQUEyQixVQUFVLFdBQVcsdUJBQXVCLHdDQUF3QyxhQUFhLEVBQUUsWUFBWSxvQ0FBb0MsK0ZBQStGLDRFQUE0RSxzQkFBc0Isd0dBQXdHLHNCQUFzQiw0RUFBNEUsWUFBWSwrQ0FBK0MsMEJBQTBCLEdBQUcsRUFBRSxRQUFRLEVBQUUsaURBQWlELG9CQUFvQixnSkFBZ0osK0pBQStKLCtIQUErSCw2QkFBNkIsNEZBQTRGLHFDQUFxQyx1QkFBdUIsa0JBQWtCLGVBQWUsbUNBQW1DLEVBQUUsc0RBQXNELGlCQUFpQixnREFBZ0QsZ0VBQWdFLFlBQVksNEJBQTRCLEtBQUssd0NBQXdDLFVBQVUsMEJBQTBCLHNJQUFzSSx5R0FBeUcsa0JBQWtCLGVBQWUsdUxBQXVMLGNBQWMscURBQXFELGtLQUFrSyxxQ0FBcUMscUJBQXFCLGdCQUFnQiwwQ0FBMEMsbUJBQW1CLGlCQUFpQixhQUFhLGFBQWEsc0ZBQXNGLGtDQUFrQyxJQUFJLE1BQU0sa0JBQWtCLGlDQUFpQyxLQUFLLGtCQUFrQiw4QkFBOEIsWUFBWSxLQUFLLElBQUkseUJBQXlCLFNBQVMsNEJBQTRCLG9DQUFvQyxzQ0FBc0MsZUFBZSwwRkFBMEYsV0FBVyw4RUFBOEUsTUFBTSxrRkFBa0YsT0FBTyw0QkFBNEIscUNBQXFDLFFBQVEsa0JBQWtCLGtDQUFrQyxJQUFJLEtBQUssYUFBYSxrQkFBa0IsMEJBQTBCLEtBQUssYUFBYSxrREFBa0QsY0FBYyxrREFBa0QsZ0JBQWdCLFNBQVMsd0NBQXdDLG9CQUFvQixJQUFJLGFBQWEsb0dBQW9HLFNBQVMsbUJBQW1CLDRCQUE0QixxQkFBcUIsWUFBWSxJQUFJLG1CQUFtQiwrQ0FBK0MsRUFBRSxXQUFXLHFDQUFxQyw2RUFBNkUsNkxBQTZMLGtCQUFrQiwwV0FBMFcsdURBQXVELGNBQWMsZ0JBQWdCLHFEQUFxRCw0REFBNEQsZ0VBQWdFLHFCQUFxQixLQUFLLGtCQUFrQiw0Q0FBNEMsU0FBUyxjQUFjLFNBQVMsMkNBQTJDLGFBQWEsSUFBSSxhQUFhLGdDQUFnQyxvRUFBb0Usa0JBQWtCLHlHQUF5RyxFQUFFLEVBQUUsc0JBQXNCLGtCQUFrQix5T0FBeU8sU0FBUyxHQUFHLGNBQWMseURBQXlELFVBQVUsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9oaWdoY2hhcnRzL2luZGljYXRvcnMvaW5kaWNhdG9ycy5qcz9jOWJmIl0sInNvdXJjZXNDb250ZW50IjpbIiEvKipcbiAqIEhpZ2hzdG9jayBKUyB2MTIuMS4yICgyMDI0LTEyLTIxKVxuICogQG1vZHVsZSBoaWdoY2hhcnRzL2luZGljYXRvcnMvaW5kaWNhdG9yc1xuICogQHJlcXVpcmVzIGhpZ2hjaGFydHNcbiAqIEByZXF1aXJlcyBoaWdoY2hhcnRzL21vZHVsZXMvc3RvY2tcbiAqXG4gKiBJbmRpY2F0b3Igc2VyaWVzIHR5cGUgZm9yIEhpZ2hjaGFydHMgU3RvY2tcbiAqXG4gKiAoYykgMjAxMC0yMDI0IFBhd2VsIEZ1cywgU2ViYXN0aWFuIEJvY2hhblxuICpcbiAqIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4gKi9mdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUodC5fSGlnaGNoYXJ0cyx0Ll9IaWdoY2hhcnRzLkNoYXJ0LHQuX0hpZ2hjaGFydHMuU2VyaWVzUmVnaXN0cnkpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJoaWdoY2hhcnRzL2luZGljYXRvcnMvaW5kaWNhdG9yc1wiLFtcImhpZ2hjaGFydHMvaGlnaGNoYXJ0c1wiXSxmdW5jdGlvbih0KXtyZXR1cm4gZSh0LHQuQ2hhcnQsdC5TZXJpZXNSZWdpc3RyeSl9KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzW1wiaGlnaGNoYXJ0cy9pbmRpY2F0b3JzL2luZGljYXRvcnNcIl09ZSh0Ll9IaWdoY2hhcnRzLHQuX0hpZ2hjaGFydHMuQ2hhcnQsdC5fSGlnaGNoYXJ0cy5TZXJpZXNSZWdpc3RyeSk6dC5IaWdoY2hhcnRzPWUodC5IaWdoY2hhcnRzLHQuSGlnaGNoYXJ0cy5DaGFydCx0LkhpZ2hjaGFydHMuU2VyaWVzUmVnaXN0cnkpfShcInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3RoaXM6d2luZG93LCh0LGUsYSk9PigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBpLHM9ezk2MDp0PT57dC5leHBvcnRzPWV9LDUxMjp0PT57dC5leHBvcnRzPWF9LDk0NDplPT57ZS5leHBvcnRzPXR9fSxuPXt9O2Z1bmN0aW9uIHIodCl7dmFyIGU9blt0XTtpZih2b2lkIDAhPT1lKXJldHVybiBlLmV4cG9ydHM7dmFyIGE9blt0XT17ZXhwb3J0czp7fX07cmV0dXJuIHNbdF0oYSxhLmV4cG9ydHMsciksYS5leHBvcnRzfXIubj10PT57dmFyIGU9dCYmdC5fX2VzTW9kdWxlPygpPT50LmRlZmF1bHQ6KCk9PnQ7cmV0dXJuIHIuZChlLHthOmV9KSxlfSxyLmQ9KHQsZSk9Pntmb3IodmFyIGEgaW4gZSlyLm8oZSxhKSYmIXIubyh0LGEpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxhLHtlbnVtZXJhYmxlOiEwLGdldDplW2FdfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSk7dmFyIG89e307ci5kKG8se2RlZmF1bHQ6KCk9Pk59KTt2YXIgbD1yKDk0NCksaD1yLm4obCkscD1yKDk2MCksZD1yLm4ocCksdT1yKDUxMiksYz1yLm4odSk7bGV0e2xpbmU6Zn09YygpLnNlcmllc1R5cGVzLHthZGRFdmVudDptLGZpcmVFdmVudDp4LGVycm9yOnksZXh0ZW5kOmcsaXNBcnJheTpELG1lcmdlOlAscGljazpDfT1oKCksdj0odCxlKT0+e2xldCBhPVtdLGk9dC5wb2ludEFycmF5TWFwLHM9ZSYmdC5kYXRhVGFibGUubW9kaWZpZWR8fHQuZGF0YVRhYmxlO2lmKCFpKXJldHVybiB0LmdldENvbHVtbihcInlcIixlKTtsZXQgbj1pLm1hcChhPT50LmdldENvbHVtbihhLGUpKTtmb3IobGV0IHQ9MDt0PHMucm93Q291bnQ7dCsrKXtsZXQgZT1pLm1hcCgoZSxhKT0+blthXT8uW3RdfHwwKTthLnB1c2goZSl9cmV0dXJuIGF9O2NsYXNzIEEgZXh0ZW5kcyBme2Rlc3Ryb3koKXt0aGlzLmRhdGFFdmVudHNUb1VuYmluZC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QoKX0pLHN1cGVyLmRlc3Ryb3kuYXBwbHkodGhpcyxhcmd1bWVudHMpfWdldE5hbWUoKXtsZXQgdD1bXSxlPXRoaXMubmFtZTtyZXR1cm4gZXx8KCh0aGlzLm5hbWVDb21wb25lbnRzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihlLGEpe3QucHVzaCh0aGlzLm9wdGlvbnMucGFyYW1zW2VdK0ModGhpcy5uYW1lU3VmZml4ZXNbYV0sXCJcIikpfSx0aGlzKSxlPSh0aGlzLm5hbWVCYXNlfHx0aGlzLnR5cGUudG9VcHBlckNhc2UoKSkrKHRoaXMubmFtZUNvbXBvbmVudHM/XCIgKFwiK3Quam9pbihcIiwgXCIpK1wiKVwiOlwiXCIpKSxlfWdldFZhbHVlcyh0LGUpe2xldCBhPWUucGVyaW9kLGk9dC54RGF0YXx8W10scz10LnlEYXRhLG49cy5sZW5ndGgscj1bXSxvPVtdLGw9W10saCxwPS0xLGQ9MCx1LGM9MDtpZighKGkubGVuZ3RoPGEpKXtmb3IoRChzWzBdKSYmKHA9ZS5pbmRleD9lLmluZGV4OjApO2Q8YS0xOyljKz1wPDA/c1tkXTpzW2RdW3BdLGQrKztmb3IoaD1kO2g8bjtoKyspYys9cDwwP3NbaF06c1toXVtwXSx1PVtpW2hdLGMvYV0sci5wdXNoKHUpLG8ucHVzaCh1WzBdKSxsLnB1c2godVsxXSksYy09cDwwP3NbaC1kXTpzW2gtZF1bcF07cmV0dXJue3ZhbHVlczpyLHhEYXRhOm8seURhdGE6bH19fWluaXQodCxlKXtsZXQgYT10aGlzO3N1cGVyLmluaXQuY2FsbChhLHQsZSk7bGV0IGk9bShkKCksXCJhZnRlckxpbmtTZXJpZXNcIixmdW5jdGlvbih7aXNVcGRhdGluZzplfSl7aWYoZSlyZXR1cm47bGV0IGk9ISFhLmRhdGFFdmVudHNUb1VuYmluZC5sZW5ndGg7aWYoIWEubGlua2VkUGFyZW50KXJldHVybiB5KFwiU2VyaWVzIFwiK2Eub3B0aW9ucy5saW5rZWRUbytcIiBub3QgZm91bmQhIENoZWNrIGBsaW5rZWRUb2AuXCIsITEsdCk7aWYoIWkmJihhLmRhdGFFdmVudHNUb1VuYmluZC5wdXNoKG0oYS5saW5rZWRQYXJlbnQsXCJ1cGRhdGVkRGF0YVwiLGZ1bmN0aW9uKCl7YS5yZWNhbGN1bGF0ZVZhbHVlcygpfSkpLGEuY2FsY3VsYXRlT24ueEF4aXMmJmEuZGF0YUV2ZW50c1RvVW5iaW5kLnB1c2gobShhLmxpbmtlZFBhcmVudC54QXhpcyxhLmNhbGN1bGF0ZU9uLnhBeGlzLGZ1bmN0aW9uKCl7YS5yZWNhbGN1bGF0ZVZhbHVlcygpfSkpKSxcImluaXRcIj09PWEuY2FsY3VsYXRlT24uY2hhcnQpYS5jbG9zZXN0UG9pbnRSYW5nZXx8YS5yZWNhbGN1bGF0ZVZhbHVlcygpO2Vsc2UgaWYoIWkpe2xldCB0PW0oYS5jaGFydCxhLmNhbGN1bGF0ZU9uLmNoYXJ0LGZ1bmN0aW9uKCl7YS5yZWNhbGN1bGF0ZVZhbHVlcygpLHQoKX0pfX0se29yZGVyOjB9KTthLmRhdGFFdmVudHNUb1VuYmluZD1bXSxhLmV2ZW50c1RvVW5iaW5kLnB1c2goaSl9cmVjYWxjdWxhdGVWYWx1ZXMoKXtsZXQgdD1bXSxlPXRoaXMuZGF0YVRhYmxlLGE9dGhpcy5wb2ludHN8fFtdLGk9dGhpcy5kYXRhVGFibGUucm93Q291bnQscz0hMCxuLHIsbyxsLGg9dGhpcy5saW5rZWRQYXJlbnQueURhdGEscD10aGlzLmxpbmtlZFBhcmVudC5wcm9jZXNzZWRZRGF0YTt0aGlzLmxpbmtlZFBhcmVudC54RGF0YT10aGlzLmxpbmtlZFBhcmVudC5nZXRDb2x1bW4oXCJ4XCIpLHRoaXMubGlua2VkUGFyZW50LnlEYXRhPXYodGhpcy5saW5rZWRQYXJlbnQpLHRoaXMubGlua2VkUGFyZW50LnByb2Nlc3NlZFlEYXRhPXYodGhpcy5saW5rZWRQYXJlbnQsITApO2xldCBkPXRoaXMubGlua2VkUGFyZW50Lm9wdGlvbnMmJnRoaXMubGlua2VkUGFyZW50LmRhdGFUYWJsZS5yb3dDb3VudCYmdGhpcy5nZXRWYWx1ZXModGhpcy5saW5rZWRQYXJlbnQsdGhpcy5vcHRpb25zLnBhcmFtcyl8fHt2YWx1ZXM6W10seERhdGE6W10seURhdGE6W119O2RlbGV0ZSB0aGlzLmxpbmtlZFBhcmVudC54RGF0YSx0aGlzLmxpbmtlZFBhcmVudC55RGF0YT1oLHRoaXMubGlua2VkUGFyZW50LnByb2Nlc3NlZFlEYXRhPXA7bGV0IHU9dGhpcy5wb2ludEFycmF5TWFwfHxbXCJ5XCJdLGM9e307aWYoZC55RGF0YS5mb3JFYWNoKHQ9Pnt1LmZvckVhY2goKGUsYSk9PntsZXQgaT1jW2VdfHxbXTtpLnB1c2goRCh0KT90W2FdOnQpLGNbZV18fChjW2VdPWkpfSl9KSxpJiYhdGhpcy5oYXNHcm91cGVkRGF0YSYmdGhpcy52aXNpYmxlJiZ0aGlzLnBvaW50cyl7aWYodGhpcy5jcm9wcGVkKXt0aGlzLnhBeGlzJiYobz10aGlzLnhBeGlzLm1pbixsPXRoaXMueEF4aXMubWF4KTtsZXQgaT10aGlzLmNyb3BEYXRhKGUsbyxsKSxzPVtcInhcIiwuLi50aGlzLnBvaW50QXJyYXlNYXB8fFtcInlcIl1dO2ZvcihsZXQgZT0wO2U8KGkubW9kaWZpZWQ/LnJvd0NvdW50fHwwKTtlKyspe2xldCBhPXMubWFwKHQ9PnRoaXMuZ2V0Q29sdW1uKHQpW2VdfHwwKTt0LnB1c2goYSl9bGV0IGg9dGhpcy5nZXRDb2x1bW4oXCJ4XCIpO249ZC54RGF0YS5pbmRleE9mKGhbMF0pLHI9ZC54RGF0YS5pbmRleE9mKGhbaC5sZW5ndGgtMV0pLC0xPT09biYmcj09PWQueERhdGEubGVuZ3RoLTImJnRbMF1bMF09PT1hWzBdLngmJnQuc2hpZnQoKSx0aGlzLnVwZGF0ZURhdGEodCl9ZWxzZSh0aGlzLnVwZGF0ZUFsbFBvaW50c3x8ZC54RGF0YS5sZW5ndGghPT1pLTEmJmQueERhdGEubGVuZ3RoIT09aSsxKSYmKHM9ITEsdGhpcy51cGRhdGVEYXRhKGQudmFsdWVzKSl9cyYmKGUuc2V0Q29sdW1ucyh7Li4uYyx4OmQueERhdGF9KSx0aGlzLm9wdGlvbnMuZGF0YT1kLnZhbHVlcyksdGhpcy5jYWxjdWxhdGVPbi54QXhpcyYmdGhpcy5nZXRDb2x1bW4oXCJ4XCIsITApLmxlbmd0aCYmKHRoaXMuaXNEaXJ0eT0hMCx0aGlzLnJlZHJhdygpKSx0aGlzLmlzRGlydHlEYXRhPSEhdGhpcy5saW5rZWRTZXJpZXMubGVuZ3RoLHgodGhpcyxcInVwZGF0ZWREYXRhXCIpfXByb2Nlc3NEYXRhKCl7bGV0IHQ9dGhpcy5vcHRpb25zLmNvbXBhcmVUb01haW4sZT10aGlzLmxpbmtlZFBhcmVudDtzdXBlci5wcm9jZXNzRGF0YS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5kYXRhTW9kaWZ5JiZlJiZlLmRhdGFNb2RpZnkmJmUuZGF0YU1vZGlmeS5jb21wYXJlVmFsdWUmJnQmJih0aGlzLmRhdGFNb2RpZnkuY29tcGFyZVZhbHVlPWUuZGF0YU1vZGlmeS5jb21wYXJlVmFsdWUpfX1BLmRlZmF1bHRPcHRpb25zPVAoZi5kZWZhdWx0T3B0aW9ucyx7bmFtZTp2b2lkIDAsdG9vbHRpcDp7dmFsdWVEZWNpbWFsczo0fSxsaW5rZWRUbzp2b2lkIDAsY29tcGFyZVRvTWFpbjohMSxwYXJhbXM6e2luZGV4OjMscGVyaW9kOjE0fX0pLGcoQS5wcm90b3R5cGUse2NhbGN1bGF0ZU9uOntjaGFydDpcImluaXRcIn0saGFzRGVyaXZlZERhdGE6ITAsbmFtZUNvbXBvbmVudHM6W1wicGVyaW9kXCJdLG5hbWVTdWZmaXhlczpbXSx1c2VDb21tb25EYXRhR3JvdXBpbmc6ITB9KSxjKCkucmVnaXN0ZXJTZXJpZXNUeXBlKFwic21hXCIsQSk7bGV0e3NtYTprfT1jKCkuc2VyaWVzVHlwZXMse2NvcnJlY3RGbG9hdDpULGlzQXJyYXk6TSxtZXJnZTpPfT1oKCk7Y2xhc3MgYiBleHRlbmRzIGt7YWNjdW11bGF0ZVBlcmlvZFBvaW50cyh0LGUsYSl7bGV0IGk9MCxzPTA7Zm9yKDtzPHQ7KWkrPWU8MD9hW3NdOmFbc11bZV0scysrO3JldHVybiBpfWNhbGN1bGF0ZUVtYSh0LGUsYSxpLHMsbixyKXtsZXQgbz10W2EtMV0sbD1uPDA/ZVthLTFdOmVbYS0xXVtuXTtyZXR1cm5bbyx2b2lkIDA9PT1zP3I6VChsKmkrcyooMS1pKSldfWdldFZhbHVlcyh0LGUpe2xldCBhPWUucGVyaW9kLGk9dC54RGF0YSxzPXQueURhdGEsbj1zP3MubGVuZ3RoOjAscj0yLyhhKzEpLG89W10sbD1bXSxoPVtdLHAsZCx1LGM9LTEsZj0wO2lmKCEobjxhKSl7Zm9yKE0oc1swXSkmJihjPWUuaW5kZXg/ZS5pbmRleDowKSxmPXRoaXMuYWNjdW11bGF0ZVBlcmlvZFBvaW50cyhhLGMscykvYSx1PWE7dTxuKzE7dSsrKWQ9dGhpcy5jYWxjdWxhdGVFbWEoaSxzLHUscixwLGMsZiksby5wdXNoKGQpLGwucHVzaChkWzBdKSxoLnB1c2goZFsxXSkscD1kWzFdO3JldHVybnt2YWx1ZXM6byx4RGF0YTpsLHlEYXRhOmh9fX19Yi5kZWZhdWx0T3B0aW9ucz1PKGsuZGVmYXVsdE9wdGlvbnMse3BhcmFtczp7aW5kZXg6MyxwZXJpb2Q6OX19KSxjKCkucmVnaXN0ZXJTZXJpZXNUeXBlKFwiZW1hXCIsYik7bGV0e3NtYTp7cHJvdG90eXBlOkV9fT1jKCkuc2VyaWVzVHlwZXMse2RlZmluZWQ6dyxlcnJvcjpTLG1lcmdlOlZ9PWgoKTshZnVuY3Rpb24odCl7bGV0IGU9W1wiYm90dG9tTGluZVwiXSxhPVtcInRvcFwiLFwiYm90dG9tXCJdLGk9W1widG9wXCJdO2Z1bmN0aW9uIHModCl7cmV0dXJuXCJwbG90XCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpfWZ1bmN0aW9uIG4odCxlKXtsZXQgYT1bXTtyZXR1cm4odC5wb2ludEFycmF5TWFwfHxbXSkuZm9yRWFjaCh0PT57dCE9PWUmJmEucHVzaChzKHQpKX0pLGF9ZnVuY3Rpb24gcigpe2xldCB0PXRoaXMsZT10LnBvaW50VmFsS2V5LGE9dC5saW5lc0FwaU5hbWVzLGk9dC5hcmVhTGluZXNOYW1lcyxyPXQucG9pbnRzLG89dC5vcHRpb25zLGw9dC5ncmFwaCxoPXtvcHRpb25zOntnYXBTaXplOm8uZ2FwU2l6ZX19LHA9W10sZD1uKHQsZSksdT1yLmxlbmd0aCxjO2lmKGQuZm9yRWFjaCgodCxlKT0+e2ZvcihwW2VdPVtdO3UtLTspYz1yW3VdLHBbZV0ucHVzaCh7eDpjLngscGxvdFg6Yy5wbG90WCxwbG90WTpjW3RdLGlzTnVsbDohdyhjW3RdKX0pO3U9ci5sZW5ndGh9KSx0LnVzZXJPcHRpb25zLmZpbGxDb2xvciYmaS5sZW5ndGgpe2xldCBlPXBbZC5pbmRleE9mKHMoaVswXSkpXSxhPTE9PT1pLmxlbmd0aD9yOnBbZC5pbmRleE9mKHMoaVsxXSkpXSxuPXQuY29sb3I7dC5wb2ludHM9YSx0Lm5leHRQb2ludHM9ZSx0LmNvbG9yPXQudXNlck9wdGlvbnMuZmlsbENvbG9yLHQub3B0aW9ucz1WKHIsaCksdC5ncmFwaD10LmFyZWEsdC5maWxsR3JhcGg9ITAsRS5kcmF3R3JhcGguY2FsbCh0KSx0LmFyZWE9dC5ncmFwaCxkZWxldGUgdC5uZXh0UG9pbnRzLGRlbGV0ZSB0LmZpbGxHcmFwaCx0LmNvbG9yPW59YS5mb3JFYWNoKChlLGEpPT57cFthXT8odC5wb2ludHM9cFthXSxvW2VdP3Qub3B0aW9ucz1WKG9bZV0uc3R5bGVzLGgpOlMoJ0Vycm9yOiBcIlRoZXJlIGlzIG5vICcrZSsnIGluIERPQ1Mgb3B0aW9ucyBkZWNsYXJlZC4gQ2hlY2sgaWYgbGluZXNBcGlOYW1lcyBhcmUgY29uc2lzdGVudCB3aXRoIHlvdXIgRE9DUyBsaW5lIG5hbWVzLlwiJyksdC5ncmFwaD10W1wiZ3JhcGhcIitlXSxFLmRyYXdHcmFwaC5jYWxsKHQpLHRbXCJncmFwaFwiK2VdPXQuZ3JhcGgpOlMoJ0Vycm9yOiBcIicrZStcIiBkb2Vzbid0IGhhdmUgZXF1aXZhbGVudCBpbiBwb2ludEFycmF5TWFwLiBUbyBtYW55IGVsZW1lbnRzIGluIGxpbmVzQXBpTmFtZXMgcmVsYXRpdmUgdG8gcG9pbnRBcnJheU1hcC5cXFwiXCIpfSksdC5wb2ludHM9cix0Lm9wdGlvbnM9byx0LmdyYXBoPWwsRS5kcmF3R3JhcGguY2FsbCh0KX1mdW5jdGlvbiBvKHQpe2xldCBlLGE9W10saT1bXTtpZih0PXR8fHRoaXMucG9pbnRzLHRoaXMuZmlsbEdyYXBoJiZ0aGlzLm5leHRQb2ludHMpe2lmKChlPUUuZ2V0R3JhcGhQYXRoLmNhbGwodGhpcyx0aGlzLm5leHRQb2ludHMpKSYmZS5sZW5ndGgpe2VbMF1bMF09XCJMXCIsYT1FLmdldEdyYXBoUGF0aC5jYWxsKHRoaXMsdCksaT1lLnNsaWNlKDAsYS5sZW5ndGgpO2ZvcihsZXQgdD1pLmxlbmd0aC0xO3Q+PTA7dC0tKWEucHVzaChpW3RdKX19ZWxzZSBhPUUuZ2V0R3JhcGhQYXRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gYX1mdW5jdGlvbiBsKHQpe2xldCBlPVtdO3JldHVybih0aGlzLnBvaW50QXJyYXlNYXB8fFtdKS5mb3JFYWNoKGE9PntlLnB1c2godFthXSl9KSxlfWZ1bmN0aW9uIGgoKXtsZXQgdD10aGlzLnBvaW50QXJyYXlNYXAsZT1bXSxhO2U9bih0aGlzKSxFLnRyYW5zbGF0ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5wb2ludHMuZm9yRWFjaChpPT57dC5mb3JFYWNoKCh0LHMpPT57YT1pW3RdLHRoaXMuZGF0YU1vZGlmeSYmKGE9dGhpcy5kYXRhTW9kaWZ5Lm1vZGlmeVZhbHVlKGEpKSxudWxsIT09YSYmKGlbZVtzXV09dGhpcy55QXhpcy50b1BpeGVscyhhLCEwKSl9KX0pfXQuY29tcG9zZT1mdW5jdGlvbih0KXtsZXQgcz10LnByb3RvdHlwZTtyZXR1cm4gcy5saW5lc0FwaU5hbWVzPXMubGluZXNBcGlOYW1lc3x8ZS5zbGljZSgpLHMucG9pbnRBcnJheU1hcD1zLnBvaW50QXJyYXlNYXB8fGEuc2xpY2UoKSxzLnBvaW50VmFsS2V5PXMucG9pbnRWYWxLZXl8fFwidG9wXCIscy5hcmVhTGluZXNOYW1lcz1zLmFyZWFMaW5lc05hbWVzfHxpLnNsaWNlKCkscy5kcmF3R3JhcGg9cixzLmdldEdyYXBoUGF0aD1vLHMudG9ZRGF0YT1sLHMudHJhbnNsYXRlPWgsdH19KGl8fChpPXt9KSk7bGV0IEc9aSxIPWgoKTtILk11bHRpcGxlTGluZXNDb21wb3NpdGlvbj1ILk11bHRpcGxlTGluZXNDb21wb3NpdGlvbnx8RztsZXQgTj1oKCk7cmV0dXJuIG8uZGVmYXVsdH0pKCkpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/highcharts/indicators/indicators.js\n"));

/***/ })

}]);